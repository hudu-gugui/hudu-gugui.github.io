<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuDu&#39;Blog</title>
  
  <subtitle>Make ardous efforts</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hudu-gugui.github.io/"/>
  <updated>2019-08-23T03:20:16.560Z</updated>
  <id>https://hudu-gugui.github.io/</id>
  
  <author>
    <name>HuDu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://hudu-gugui.github.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
    <id>https://hudu-gugui.github.io/Java8新特性.html</id>
    <published>2019-08-23T01:33:59.000Z</published>
    <updated>2019-08-23T03:20:16.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1></blockquote><p>Lambda表达式，也可以称为闭包，Lambda表达式允许把函数作为一个方法的参数(函数作为参数传递进方法中)。使用Lambda表达式可以使代码变得更加简洁紧凑。</p><blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters)-&gt;expression</span><br><span class="line">或</span><br><span class="line">(parameters)-&gt;&#123;statements;&#125;</span><br></pre></td></tr></table></figure><p>以下是Lambda表达式的重要特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。<a id="more"></a></li></ul><blockquote><h1 id="Lambda表达式实例"><a href="#Lambda表达式实例" class="headerlink" title="Lambda表达式实例"></a>Lambda表达式实例</h1><p>Lambda表达式的简单例子：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.不需要参数，返回值为5</span></span><br><span class="line">()-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接收一个参数(数字类型)，返回其2倍的值</span></span><br><span class="line">x-&gt;<span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.接受两个参数(数字),并返回他们的差值</span></span><br><span class="line">(x,y)-&gt;x-y</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接收2个int类型整数，返回他们的和</span></span><br><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.接受一个String对象，并在控制台打印，不返回任何值(看起来像是返回void)</span></span><br><span class="line">(String s)-&gt;System.out.print(s)</span><br></pre></td></tr></table></figure><p><strong>Lambda表达式实例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Java8Test1 tester = <span class="keyword">new</span> Java8Test1();</span><br><span class="line">        <span class="comment">//普通的创建一个对象的过程</span></span><br><span class="line">        MathOperation mo = <span class="keyword">new</span> MathOperation() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a*b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//上面的用Lambda表达式简化，因为有两个参数，括号无法省略</span></span><br><span class="line">        <span class="comment">//因为返回只有一行，所有可以省略return；</span></span><br><span class="line">        MathOperation mo1 = (a, b) -&gt; a*b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"2x3="</span>+tester.operate(<span class="number">2</span>,<span class="number">3</span>,mo1));</span><br><span class="line"></span><br><span class="line">        GreetingService gs = <span class="keyword">new</span> GreetingService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello"</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//用Lambda表达式简化</span></span><br><span class="line">        GreetingService gs1 = message -&gt; System.out.println(<span class="string">"Hello "</span>+message);</span><br><span class="line">        <span class="comment">//最简洁的表达式</span></span><br><span class="line">        GreetingService gs2 = System.out::println;</span><br><span class="line"></span><br><span class="line">        gs1.sayMessage(<span class="string">"Runoob"</span>);</span><br><span class="line">        gs2.sayMessage(<span class="string">"Google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,MathOperation mathOperation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="images/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="Lambda表达式"></p><p><strong>使用Lambda表达式注意一下两点</strong></p><ul><li>Lambda表达式主要用来定义行内执行的方法类型接口，例如，一个简单的方法接口。在上面的例子中，使用Lambda表达式来定义MathOperation接口的方法，然后定义了sayMessage的执行。</li><li>Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul><blockquote><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1></blockquote><p>Lambda表达式只能引用标记了final的外层局部变量，就是说不能再Lambda外部修改定义在域外的局部变量，否则会编译错误。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Test1_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String saluation = <span class="string">"Hello "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当Lambda表达式引用saluation1时，成员变量默认是final修饰，不能修改。</span></span><br><span class="line">        String saluation = <span class="string">"Hello "</span>;</span><br><span class="line">        GreetingService gs = message -&gt; System.out.println(saluation+message);<span class="comment">//并且定义的传入的参数名不能和局部变量的变量名一样</span></span><br><span class="line">        gs.sayMessage(<span class="string">"World"</span>);</span><br><span class="line"><span class="comment">//        saluation1="123";//无法修改</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="images/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="Lambda表达式变量作用域"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;Lambda表达式，也可以称为闭包，Lambda表达式允许把函数作为一个方法的参数(函数作为参数传递进方法中)。使用Lambda表达式可以使代码变得更加简洁紧凑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(parameters)-&amp;gt;expression&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(parameters)-&amp;gt;&amp;#123;statements;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下是Lambda表达式的重要特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。&lt;/li&gt;
&lt;li&gt;可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。&lt;/li&gt;
&lt;li&gt;可选的大括号：如果主体包含了一个语句，就不需要使用大括号。&lt;/li&gt;
&lt;li&gt;可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java8新特性" scheme="https://hudu-gugui.github.io/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="Lambda表达式" scheme="https://hudu-gugui.github.io/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="方法引用" scheme="https://hudu-gugui.github.io/tags/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    
      <category term="函数式接口" scheme="https://hudu-gugui.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="默认方法" scheme="https://hudu-gugui.github.io/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    
      <category term="Stream" scheme="https://hudu-gugui.github.io/tags/Stream/"/>
    
      <category term="Optional类" scheme="https://hudu-gugui.github.io/tags/Optional%E7%B1%BB/"/>
    
      <category term="Nashorn及JavaScript引擎" scheme="https://hudu-gugui.github.io/tags/Nashorn%E5%8F%8AJavaScript%E5%BC%95%E6%93%8E/"/>
    
      <category term="新的日期时间API" scheme="https://hudu-gugui.github.io/tags/%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API/"/>
    
      <category term="Base64" scheme="https://hudu-gugui.github.io/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>IO流和文件系统</title>
    <link href="https://hudu-gugui.github.io/IO%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"/>
    <id>https://hudu-gugui.github.io/IO流和文件系统.html</id>
    <published>2019-08-22T03:30:20.000Z</published>
    <updated>2019-08-22T03:30:20.966Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://hudu-gugui.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>https://hudu-gugui.github.io/网络编程.html</id>
    <published>2019-08-21T11:58:20.000Z</published>
    <updated>2019-08-22T03:29:16.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1></blockquote><p><strong>1.IP地址</strong><br>IP是Internet Protocol【网络协议】的缩写，IP地址指的是在一个网络【万维网】环境中用于确定某一台计算机主机的标识；IP由4个字节组成，每个字节是一段，每段之间用“.”分隔；一个计算机主机可以有多个IP地址；但是一个IP地址只能确定唯一的一台计算机主机。<br><strong>2.端口</strong><br>为计算机中运行的网络应用程序分配的应用程序标识；取值范围值0到65535，但是0到1023【前1024个】由操作系统软件保留；</p><a id="more"></a><p><strong>3.URL</strong><br>称为统一资源定位符：网址<br>例如<font color="red"><a href="https://www.baidu.com:80/index.html" target="_blank" rel="noopener">https://www.baidu.com:80/index.html</a></font></p><p>https://网络传输协议<br><a href="http://www.baidu.com是主机名" target="_blank" rel="noopener">www.baidu.com是主机名</a><br>80位服务器的端口<br>/index.html为服务器的根目录和资源</p><p><strong>4.URI统一资源标识符</strong><br>就是如上所述的x.html<br>DNS：Domain Name System。域名系统，域名解析器</p><p><strong>5.Java中使用InetAdderss类描述IP地址</strong><br>InetAdderss    IPv4<br>InetAdderss Ipv6</p><p>hosts文件：文件中可以配置主机名到IP地中的映射关系：<br>windows：C:\Windows\System32\drivers\etc\hosts<br>Linux/Unix: /etc/hosts</p><p>格式：<br>IP地址 &nbsp; 主机名<br>127.0.0.1 &nbsp; localhost</p><blockquote><h1 id="2-TCP编程【TCP协议】"><a href="#2-TCP编程【TCP协议】" class="headerlink" title="2.TCP编程【TCP协议】"></a>2.TCP编程【TCP协议】</h1></blockquote><p><strong>1.Socket</strong><br>主要用于TCP通信的客户端<br>Socket(String host, int port);    创建Socket对象，用于连接服务器进行通信，<br>在使用此构造器创建Socket对象的时候，客户端的Socket就会根据参数传递的IP地址和端口<br>去连接服务器端的ServerSocket；</p><p><strong>2.ServerSocket</strong><br>主要用于TCP通信服务端；<br>ServerSocket(int port);  // 此构造器用于创建一个服务器端的ServerSocket对象，<br>在创建时需要监听一个端口，当客户端的Socket对象连接此端口时，就能被该ServerSocket对象识别并且接收；</p><p>Socket accept();    // 在服务器端用于监听并获取客户端的Socket对象，目的是建立传输数据的通道；<br>实际上服务器端的ServerSocket并不会直接和客户端的Socket进行数据传输【通信】，<br>通信通道的建立是由服务器端的ServerSocket所获取到的客户端的Socket对象以及客户端本身的Socket对象建立的；<br>此方法是阻塞式方法；</p><p><strong>3.TCP协议的特点</strong><br>    1.可靠的网络协议，安全，数据传输之前要“三次握手”；<br>    2.效率相对低下，但是安全；<br>    3.在传输数据时，客户端和服务器端都必须“在线”；</p><p>练习：1.客户端循环发，服务器循环接收；<br>      2.基于TCP的聊天系统；<br>      3.多线程聊天；</p><blockquote><h1 id="3-UDP编程【UDP协议】，发送端、接收端"><a href="#3-UDP编程【UDP协议】，发送端、接收端" class="headerlink" title="3.UDP编程【UDP协议】，发送端、接收端"></a>3.UDP编程【UDP协议】，发送端、接收端</h1></blockquote><p>1.面向无连接；<br>2.不安全，数据容易丢失；<br>3.效率相对于TCP高一些；<br>4.UDP发送的数据会被封装成数据报包，每个数据报的大小不会超过64KB;</p><p>5.在Java中基于UDP的编程由DatagramSocket提供数据传输的两端；由DatagramPacket封装数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket：</span><br><span class="line">DatagramSocket();  <span class="comment">//创建发送端的Socket对象</span></span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port);  <span class="comment">//创建接收端的Socket对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> <span class="comment">//从此套接字接收数据报包。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span> <span class="comment">//从此套接字发送数据报包。</span></span></span><br><span class="line"><span class="function">DatagramPacket：</span></span><br><span class="line"><span class="function"><span class="comment">//对要发送的数据进行封装或者用该类的对象来接收</span></span></span><br><span class="line"><span class="function"><span class="comment">//DatagramSocket收到的数据；</span></span></span><br><span class="line"><span class="function"><span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//构造 DatagramPacket，用来接收长度为 length 的数据包。</span></span></span><br><span class="line"><span class="function"><span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</span></span></span><br></pre></td></tr></table></figure><blockquote><h1 id="TCP代码实例"><a href="#TCP代码实例" class="headerlink" title="TCP代码实例"></a>TCP代码实例</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket cs = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">1666</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        OutputStream os = cs.getOutputStream();</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(os, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入要发送的消息："</span>);</span><br><span class="line">            String msg = reader.readLine();</span><br><span class="line">            pw.println(msg);</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader</span><br><span class="line">                    (<span class="keyword">new</span> InputStreamReader(cs.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">"服务器消息："</span>+br.readLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">1666</span>);</span><br><span class="line">        String sIP = ss.getInetAddress().getHostAddress();</span><br><span class="line">        System.out.println(<span class="string">"服务"</span>+sIP+<span class="string">"启动了！"</span>);</span><br><span class="line">        Socket cs = ss.accept();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            String cIP = cs.getInetAddress().getHostAddress();</span><br><span class="line">            System.out.println(<span class="string">"客户端"</span>+cIP+<span class="string">"进来了"</span>);</span><br><span class="line">            InputStream is = cs.getInputStream();</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            String msg = br.readLine();</span><br><span class="line">            System.out.println(<span class="string">"客户端消息:"</span>+msg);</span><br><span class="line">            OutputStream os = cs.getOutputStream();</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(os, <span class="keyword">true</span>);</span><br><span class="line">            pw.println(<span class="string">"接收到消息"</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="/images/TCP_2.png" alt="客户端"><br><img src="/images/TCP_1.png" alt="服务器端"></p><blockquote><h1 id="UDP实例代码"><a href="#UDP实例代码" class="headerlink" title="UDP实例代码"></a>UDP实例代码</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SendThread().start();</span><br><span class="line">        <span class="keyword">new</span> ReceiveThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            InetAddress ia = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">45678</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//                System.out.println("请输入消息");</span></span><br><span class="line">                line=reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"886"</span>.equals(line))<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = line.getBytes();</span><br><span class="line">                <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">                DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length, ia, port);</span><br><span class="line">                ds.send(dp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">45678</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                ds.receive(dp);</span><br><span class="line">                String sIP = dp.getAddress().getHostAddress();</span><br><span class="line">                <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">                <span class="keyword">int</span> length1 = data.length;</span><br><span class="line">                String data1 = <span class="keyword">new</span> String(data,<span class="number">0</span>,length1);</span><br><span class="line">                System.out.println(sIP+<span class="string">"\t说;"</span>+data1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行效果图：<br><img src="images/" alt="UDP"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.IP地址&lt;/strong&gt;&lt;br&gt;IP是Internet Protocol【网络协议】的缩写，IP地址指的是在一个网络【万维网】环境中用于确定某一台计算机主机的标识；IP由4个字节组成，每个字节是一段，每段之间用“.”分隔；一个计算机主机可以有多个IP地址；但是一个IP地址只能确定唯一的一台计算机主机。&lt;br&gt;&lt;strong&gt;2.端口&lt;/strong&gt;&lt;br&gt;为计算机中运行的网络应用程序分配的应用程序标识；取值范围值0到65535，但是0到1023【前1024个】由操作系统软件保留；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="网络编程" scheme="https://hudu-gugui.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="https://hudu-gugui.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="https://hudu-gugui.github.io/tags/UDP/"/>
    
      <category term="IP" scheme="https://hudu-gugui.github.io/tags/IP/"/>
    
      <category term="port" scheme="https://hudu-gugui.github.io/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>线程(Thread)</title>
    <link href="https://hudu-gugui.github.io/%E7%BA%BF%E7%A8%8B-Thread.html"/>
    <id>https://hudu-gugui.github.io/线程-Thread.html</id>
    <published>2019-08-12T10:48:30.000Z</published>
    <updated>2019-08-12T12:26:38.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1></blockquote><p><strong>1.进程：</strong><br>进程就是某一个应用程序在计算机中运行时计算机为该应用程序所分配的资源；在多任务计算机中一个计算机可以同时执行多个程序，也就是有多个进程；进程不具备计算能力的；<br><strong>2.线程：</strong><br>线程是进程中使用【利用】计算机为进程所分配的计算机资源进行数据计算的基本单位；一个进程中至少要包含一个线程，否则该进程无意义；线程具有随机【执行】性，线程的运行时接受CPU的调度的，当CPU调度到哪个线程就执行哪个线程，并且一个CPU在某个时间片之内【同一时刻】只能执行一个线程，形象的理解为线程在抢夺CPU资源，如果抢到了就执行；<br><strong>3.多线程</strong><br>当一个进程中多个线程“同时”执行，此现象称之为多线程；</p><a id="more"></a><blockquote><h1 id="自定义线程和创建执行线程"><a href="#自定义线程和创建执行线程" class="headerlink" title="自定义线程和创建执行线程"></a>自定义线程和创建执行线程</h1></blockquote><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类:"></a>1.继承Thread类:</h2><p>(1)Thread类中默认的run方法的方法体为“空”，不会执行任何代码；<br>(2)继承该类之后，需要重写该类中的run()方法，将自定义的线程需要执行的代码写在run()方法中，在该线程被启动之后，线程就会去执行run()方法中的代码；<br>(3)线程的启动是调用Thread类中的start()方法，而不能直接调用run()方法，如果调用run方法就是最简单的方法调用而不是线程的启动；<br>(4)Java程序在执行的时候，JVM进程会启动一个线程来执行该程序的主方法，此线程称之为main线程【主线程，线程的名字叫“main”】；只有主线程在执行main方法的时候才能执行到main方法中定义的创建和启动其他线程的代码，如果启动了多个线程，则这些线程的默认的名字是按照启动顺序从“Thread-0”到“Thread-N”;<br>(5)start()方法和run()方法的区别：<br>&emsp;1.run方法中用于定义线程执行的代码；如果直接调用run方法，则相当于普通方法调用；<br>&emsp;2.start方法用于启动线程，让该线程能够抢占CPU资源而执行；</p><h2 id="2-实现Runnable接口："><a href="#2-实现Runnable接口：" class="headerlink" title="2.实现Runnable接口："></a>2.实现Runnable接口：</h2><p>1.该接口中只有一个方法——run方法；<br>2.自定义类实现了该接口并且重写run方法，在run方法中定义线程要执行的代码；<br>3.实现了该接口的类并不是线程类，只是表示该类的对象可以作为线程对象的执行目标来执行；</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><p>该接口中有一个方法call方法，该方法是具有返回值的，如果线程在执行的过程中调用了一个具有返回值的方法，则可以使用该接口创建线程；</p><blockquote><h1 id="线程的状态-生命周期"><a href="#线程的状态-生命周期" class="headerlink" title="线程的状态(生命周期)"></a>线程的状态(生命周期)</h1></blockquote><p>1.并发：多个线程同时执行称之为并发；<br>并行：多个进程同时执行称之为并行；</p><p>2.线程中的优先级：<br>Java中的每个线程都有优先级，但是优先级高的线程被CPU调度的概率高于优先级低的线程；设置线程的优先级并不能让CPU立即去执行线程，而是让CPU有更多机会来调度该线程；线程的优先级被分为10个等级，用int类型的1到10表示，10表示优先级最高，1表示优先级最低，5是Java中所有线程的默认优先级；</p><p>2.Thread类中方法：</p><ol><li>static Thread currentThread();  // 获取此代码所在的方法正在被执行的线程对象；</li><li>static void sleep(long ms); // 让执行此代码所在的方法的线程暂时停止执行【CPU不再调度该线程】，等到参数所表示的时间结束之后可以继续执行；</li></ol><p>3.Object类中的方法：</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.进程：&lt;/strong&gt;&lt;br&gt;进程就是某一个应用程序在计算机中运行时计算机为该应用程序所分配的资源；在多任务计算机中一个计算机可以同时执行多个程序，也就是有多个进程；进程不具备计算能力的；&lt;br&gt;&lt;strong&gt;2.线程：&lt;/strong&gt;&lt;br&gt;线程是进程中使用【利用】计算机为进程所分配的计算机资源进行数据计算的基本单位；一个进程中至少要包含一个线程，否则该进程无意义；线程具有随机【执行】性，线程的运行时接受CPU的调度的，当CPU调度到哪个线程就执行哪个线程，并且一个CPU在某个时间片之内【同一时刻】只能执行一个线程，形象的理解为线程在抢夺CPU资源，如果抢到了就执行；&lt;br&gt;&lt;strong&gt;3.多线程&lt;/strong&gt;&lt;br&gt;当一个进程中多个线程“同时”执行，此现象称之为多线程；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="线程" scheme="https://hudu-gugui.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="thread" scheme="https://hudu-gugui.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://hudu-gugui.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://hudu-gugui.github.io/面向对象.html</id>
    <published>2019-08-11T02:46:28.000Z</published>
    <updated>2019-08-11T03:12:25.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1></blockquote><p>(1)包：最好是域名倒过来，要求所有的额字母小写。<br>(2)类或者接口：如果是一个单词首字母大写，如果是多个单词，每个单词首字母大写(驼峰命名)<br>(3)方法或变量：如果是一个单词，首字母小写，如果是多个单词，从第二个单词首字母大写<br>(4)常量：如果是一个单词，所有字母大写，如果是多个单词，所有的单词大写，用下划线区分每个单词<br>常量的概念：在执行过程中其值不能改变，字符串常量（双引号括起来的内容），整数常量，小数常量，字符常量，布尔常量，空常量</p><a id="more"></a><blockquote><h1 id="理解对象的概念"><a href="#理解对象的概念" class="headerlink" title="理解对象的概念"></a>理解对象的概念</h1></blockquote><p>面向对象的开发方法把软件系统看成各种对象的集合，对象就是最小的子系统，一组相关的对象能够组合成更复杂的子系统。面向对象的开发方法将软件系统看成各种对象的集合，接近人的自然思维方式。<br>对象是对问题领域中事件的抽象。对象具有以下特性：<br>(1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。例如学生，成绩单、教师、课和教室。<br>(2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。<br>(3) 对象具有属性和行为。<br>例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。<br>例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发短信receiveMessage()和发短信sendMessage().<br>(4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。对象的某些行为会改变对象自身的状态，即属性的取值。例如小张本来体重为40kg，经为减肥后，体重减到45kg.<br>肥胖状态: 40kg—减肥行为—肥胖状态: 35kg<br>(5) 每个对象都是某个类的实例。小张和小王都属于学生类、中国和美国都属于国家类、中文和英文都属于语言类。类是具有相同属性和行为的对象的集合。</p><p>同一个类的所有实例都有相同属性，但属性取值不一事实上相同，但是它们的状态不一定相同。例如小张和小王都属于学生类，都有姓名、性别、年龄、身高和体重这些属性，但是他们的属性取值不同。</p><p>同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。</p><blockquote><h1 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h1></blockquote><p>类是一组具有相同属性和行为对象的模板。面向对象编程的主要任务就是定义对象模型中的各个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**attributes of a teacher*/</span></span><br><span class="line">          <span class="keyword">private</span> String name;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Creates a new instance of Teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.salary = salary;</span><br><span class="line">              <span class="keyword">this</span>.age = age;</span><br><span class="line">              <span class="keyword">this</span>.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/**operations on properties */</span></span><br><span class="line">          <span class="comment">/** get the name of this teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">          <span class="comment">/**get the salary of this teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> salary; &#125;</span><br><span class="line">          <span class="comment">/**get the age of teacher teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">          ……</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>代码解析：</p><p>(1)package sample;<br>包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。<br>(2)public class Teacher{···}<br>类的声明语句，类名为Teacherr,public修饰符意味着这个类可以被公开访问：<br>类的声明格式：<br>class 类名 {<br>             类内容<br>         }</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;(1)包：最好是域名倒过来，要求所有的额字母小写。&lt;br&gt;(2)类或者接口：如果是一个单词首字母大写，如果是多个单词，每个单词首字母大写(驼峰命名)&lt;br&gt;(3)方法或变量：如果是一个单词，首字母小写，如果是多个单词，从第二个单词首字母大写&lt;br&gt;(4)常量：如果是一个单词，所有字母大写，如果是多个单词，所有的单词大写，用下划线区分每个单词&lt;br&gt;常量的概念：在执行过程中其值不能改变，字符串常量（双引号括起来的内容），整数常量，小数常量，字符常量，布尔常量，空常量&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="面向对象" scheme="https://hudu-gugui.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="命名" scheme="https://hudu-gugui.github.io/tags/%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>枚举(enum/Enum)</title>
    <link href="https://hudu-gugui.github.io/%E6%9E%9A%E4%B8%BE-enum-Enum.html"/>
    <id>https://hudu-gugui.github.io/枚举-enum-Enum.html</id>
    <published>2019-08-09T03:07:09.000Z</published>
    <updated>2019-08-09T03:37:38.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="什么是枚举"><a href="#什么是枚举" class="headerlink" title="什么是枚举"></a>什么是枚举</h1></blockquote><p>枚举指的是Java语言中类的一种，但是这只能够类的对象的个数是有限个</p><blockquote><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1></blockquote><p>一个类只能产生一个对象，不管这类有多少个使用者，这些使用者获取到的对象都是同一个</p><h2 id="定义一个单例模式类："><a href="#定义一个单例模式类：" class="headerlink" title="定义一个单例模式类："></a>定义一个单例模式类：</h2><p>1.构造器私有化<br>2.提供公共的获取该对象的方式</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式的类</span></span><br><span class="line"><span class="comment">//懒汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Util u = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Util</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个公共的访问该对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Util <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u==<span class="keyword">null</span>) u = <span class="keyword">new</span> Util();</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恶汉模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Tool t = <span class="keyword">new</span> Tool();</span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Tool</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个公共的获取该对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Tool <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h1></blockquote><p>1.关键字enum 枚举类是一种特殊的类，特殊在默认将构造器私有化以及特殊在枚举类中直接提供了该类的对象，并且该类的对象是由public static final修饰的，自定义的枚举类默认继承自java.lang.Enum类(抽象类)</p><p>2.由于枚举类也是一种特殊的类，所以枚举类中也能定义变量，方法(成员方法，类方法，抽象方法)如果枚举类中有抽象方法，则需要在该枚举类的每个对象上都重写方法</p><p>3.枚举类可以实现接口，但不能继承其它类(默认已经实现了Enum类)；枚举类实现接口之后需要重写接口中的抽象方法，抽线方法中的重写方法有两种形式：<br>&emsp;1.直接在该枚举类中重写，该枚举类的所有<br>&emsp;2.在枚举类的每个对象中重写接口中的抽象方法，每个对象在调用重写的方法时，调用的是</p><p>4.枚举类中可以定义多个构造器，构造器默认是private修饰，或者可以在定义构造器时显示的使用private修饰当定义其它构造器后会覆盖无参构造器，此时枚举类中每个对象就不能通过无参构造器来创建对象:<br>&emsp;1.在枚举类中提供无参构造器(不推荐，因为在枚举类中的构造器时私有的，没有办法再其它类中调用，所以定义的其它构造器是无意义的)<br>&emsp;2.在每个枚举类对象上提供使用其它自定义的构造器创建对象时的参数(实参)；</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;什么是枚举&quot;&gt;&lt;a href=&quot;#什么是枚举&quot; class=&quot;headerlink&quot; title=&quot;什么是枚举&quot;&gt;&lt;/a&gt;什么是枚举&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;枚举指的是Java语言中类的一种，但是这只能够类的对象的个数是有限个&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;一个类只能产生一个对象，不管这类有多少个使用者，这些使用者获取到的对象都是同一个&lt;/p&gt;
&lt;h2 id=&quot;定义一个单例模式类：&quot;&gt;&lt;a href=&quot;#定义一个单例模式类：&quot; class=&quot;headerlink&quot; title=&quot;定义一个单例模式类：&quot;&gt;&lt;/a&gt;定义一个单例模式类：&lt;/h2&gt;&lt;p&gt;1.构造器私有化&lt;br&gt;2.提供公共的获取该对象的方式&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="枚举" scheme="https://hudu-gugui.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="enum" scheme="https://hudu-gugui.github.io/tags/enum/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="https://hudu-gugui.github.io/%E6%B3%9B%E5%9E%8B.html"/>
    <id>https://hudu-gugui.github.io/泛型.html</id>
    <published>2019-08-07T11:40:28.000Z</published>
    <updated>2019-08-09T03:04:41.314Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2></blockquote><p>广泛的类型，类型参数化，所以泛型也称为泛型参数:<t></t></p><blockquote><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2></blockquote><h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 类名&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-注意"><a href="#2-注意" class="headerlink" title="2.注意"></a>2.注意</h3><p>当有子类继承泛型类，如果在泛型类上没有确定(指定)泛型参数的实际类型，则需要将子类也定义为泛型类型。泛型参数保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  T <span class="title">getObj</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-泛型类也可以定义泛型参数的抽象类"><a href="#3-泛型类也可以定义泛型参数的抽象类" class="headerlink" title="3.泛型类也可以定义泛型参数的抽象类"></a>3.泛型类也可以定义泛型参数的抽象类</h3><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="1.语法"></a>1.语法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-注意-1"><a href="#2-注意-1" class="headerlink" title="2.注意"></a>2.注意</h3><p>当子类实现了该泛型接口以后，如果没有指定泛型参数的实际类型，则该子类也必须定义为泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> <span class="keyword">implements</span> <span class="title">C</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><h3 id="1-成员方法-非静态"><a href="#1-成员方法-非静态" class="headerlink" title="1.成员方法(非静态)"></a>1.成员方法(非静态)</h3><p>权限修饰符<t> 返回类型 方法名(T t){</t></p><p>}</p><h3 id="2-类方法-静态方法"><a href="#2-类方法-静态方法" class="headerlink" title="2.类方法(静态方法)"></a>2.类方法(静态方法)</h3><p>1.静态方法中不能直接使用泛型类上的泛型参数：否则需要将该方法也定义为泛型方法，让其泛型类上的泛型参数一致即可，静态方法上的泛型参数可以不用和类上的泛型参数一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;Q&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Q q)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">haah</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义泛型方法</span></span><br><span class="line">    &lt;Q&gt;<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T o)</span></span>&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么使用泛型？"><a href="#为什么使用泛型？" class="headerlink" title="为什么使用泛型？"></a>为什么使用泛型？</h2><p>将错误(异常)出现的时期由运行期转移到编译期</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>当不能给泛型参数传递什么实际的类型时，可以使用通配符”&lt;?&gt;”来表示具体的泛型参数</p><h2 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h2><h3 id="泛型上限"><a href="#泛型上限" class="headerlink" title="泛型上限"></a>泛型上限</h3><p>所传递的参数类型只能是指定的类型本身或者其子类类型<br>&lt;? extends 上限类型&gt;</p><h3 id="泛型下限"><a href="#泛型下限" class="headerlink" title="泛型下限"></a>泛型下限</h3><p>所传递的参数类型只能是指定的类型本身或者其父类类型<br>&lt;? super 下限类型&gt;</p><h3 id="集合中关于泛型通配符和上下限的特殊情况"><a href="#集合中关于泛型通配符和上下限的特殊情况" class="headerlink" title="集合中关于泛型通配符和上下限的特殊情况"></a>集合中关于泛型通配符和上下限的特殊情况</h3><p>集合类在创建对象的时候，如果该集合的泛型参数有通配符，则该集合不能做添加元素的操作，一般只用于接收其它集合的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">List&lt;B&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> C());</span><br><span class="line">        list.add(<span class="keyword">new</span> D());</span><br><span class="line">        g.show2(list);</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list1 = g.show3();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //泛型只要是B类或者B类的子类就行</span></span><br><span class="line"><span class="comment">//    void show(X&lt;? extends B&gt; x)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(x);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //泛型要是B类或者B类的父类就行</span></span><br><span class="line"><span class="comment">//    void show1(X&lt;? extends B&gt; x)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(x);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法中的类型只要是B类或者B类的子类就行</span></span><br><span class="line">    <span class="comment">//当方法参数中有了通配符，集合不能添加，只能获取</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(List&lt;? extends B&gt; list)</span></span>&#123;</span><br><span class="line"><span class="comment">//        list.add(new B());</span></span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">show3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;广泛的类型，类型参数化，所以泛型也称为泛型参数:&lt;t&gt;&lt;/t&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;泛型类&quot;&gt;&lt;a href=&quot;#泛型类&quot; class=&quot;headerlink&quot; title=&quot;泛型类&quot;&gt;&lt;/a&gt;泛型类&lt;/h2&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;1-语法&quot;&gt;&lt;a href=&quot;#1-语法&quot; class=&quot;headerlink&quot; title=&quot;1.语法&quot;&gt;&lt;/a&gt;1.语法&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; 类名&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; T t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setObj&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.t = t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
      <category term="泛型" scheme="https://hudu-gugui.github.io/categories/Java/%E6%B3%9B%E5%9E%8B/"/>
    
    
      <category term="泛型" scheme="https://hudu-gugui.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="泛型通配符" scheme="https://hudu-gugui.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    
      <category term="泛型限定" scheme="https://hudu-gugui.github.io/tags/%E6%B3%9B%E5%9E%8B%E9%99%90%E5%AE%9A/"/>
    
  </entry>
  
  <entry>
    <title>Java高级编程_集合体系</title>
    <link href="https://hudu-gugui.github.io/Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB.html"/>
    <id>https://hudu-gugui.github.io/Java高级编程-集合体系.html</id>
    <published>2019-08-07T10:13:28.000Z</published>
    <updated>2019-08-07T11:39:13.917Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a>集合体系</h1></blockquote><p><font size></font><br><strong>1.集合本身就是一个对象，用于存储其它对象；</strong><br><font color="red"><strong>2.集合中只能存储引用类型的数据，不能存储基本数据类型的数据；</strong></font><br><strong>3.集合和数组一样，都可以理解为存储数据的容器;</strong><br><strong>4.Collection集合：学顶层用底层;在单列体系中，Collectoin接口并不是最顶层接口,该接口有一个父接口：Iterable接口(单列集合的最顶层接口);</strong></p><a id="more"></a><h2 id="emsp-1-Iterator接口：迭代器接口：能够对实现了Iterable接口的集合进行遍历访问-迭代-；"><a href="#emsp-1-Iterator接口：迭代器接口：能够对实现了Iterable接口的集合进行遍历访问-迭代-；" class="headerlink" title="&emsp;1.Iterator接口：迭代器接口：能够对实现了Iterable接口的集合进行遍历访问(迭代)；"></a>&emsp;<strong>1.Iterator接口：迭代器接口：能够对实现了Iterable接口的集合进行遍历访问(迭代)；</strong></h2><h2 id="emsp-2-Iterable接口中的方法："><a href="#emsp-2-Iterable接口中的方法：" class="headerlink" title="&emsp;2.Iterable接口中的方法："></a>&emsp;<strong>2.Iterable接口中的方法：</strong></h2><p>&emsp;&emsp;Iterator iterator();<em>//获取迭代器对象，用于迭代遍历，实现了Iterable接口的集合</em></p><h2 id="emsp-3-Iterator接口中的方法："><a href="#emsp-3-Iterator接口中的方法：" class="headerlink" title="&emsp;3.Iterator接口中的方法："></a>&emsp;<strong>3.Iterator接口中的方法：</strong></h2><p>&emsp;&emsp;hasNext();&emsp;<em>//判断有没有下一个元素</em><br>&emsp;&emsp;next();&emsp;<em>//取出下一个元素</em><br>&emsp;&emsp;remove();&emsp;<em>//移除当前获取到的元素</em></p><h2 id="emsp-4-Collection接口中的方法"><a href="#emsp-4-Collection接口中的方法" class="headerlink" title="&emsp;4.Collection接口中的方法:"></a>&emsp;<strong>4.Collection接口中的方法:</strong></h2><p>&emsp;&emsp;add(Object o);&emsp;<em>//添加元素</em><br>&emsp;&emsp;remove(Object o);&emsp;<em>//删除元素</em><br>&emsp;&emsp;size();&emsp;<em>//获取元素个数</em><br>&emsp;&emsp;clear;&emsp;<em>//清空集合</em></p><h2 id="emsp-5-List接口，该类集合表示有序-向集合中添加元素的顺序和从集合中取出元素的顺序时一致的-，可重复的集合-并且集合中的元素可以为null。"><a href="#emsp-5-List接口，该类集合表示有序-向集合中添加元素的顺序和从集合中取出元素的顺序时一致的-，可重复的集合-并且集合中的元素可以为null。" class="headerlink" title="&emsp;5.List接口，该类集合表示有序(向集合中添加元素的顺序和从集合中取出元素的顺序时一致的)，可重复的集合,并且集合中的元素可以为null。"></a>&emsp;<strong>5.List接口，该类集合表示有序(向集合中添加元素的顺序和从集合中取出元素的顺序时一致的)，可重复的集合,并且集合中的元素可以为null。</strong></h2><p>&emsp;&emsp;add(int index,Object o);&emsp;<em>//在指定位置添加元素</em><br>&emsp;&emsp;remove(int index);&emsp;<em>//移除并返回指定位置上的元素</em><br>&emsp;&emsp;set(int index,Object o);&emsp;<em>//修改指定位置的元素</em><br>&emsp;&emsp;get(int index);&emsp;<em>//获取指定位置上的元素</em></p><h2 id="emsp-6-ArrayList类："><a href="#emsp-6-ArrayList类：" class="headerlink" title="&emsp;6.ArrayList类："></a>&emsp;<strong>6.ArrayList类：</strong></h2><p>&emsp;&emsp;List集合的具体实现，底层的实现原理是可变长度的数组；数组中只能添加同一种类型的元素，集合在没有指定泛型(jdk1.5中出现)的情况下可以添加任意引用类型(Object类型，自动转化，向上转型，显示转型)的数据；在没有指定泛型的时候，ArrayList把所有的类型升级为Object类型，本质上，其实还是原来的类型</p><h2 id="emsp-7-List集合元素的迭代遍历："><a href="#emsp-7-List集合元素的迭代遍历：" class="headerlink" title="&emsp;7.List集合元素的迭代遍历："></a>&emsp;<strong>7.List集合元素的迭代遍历：</strong></h2><p>&emsp;&emsp;1.通过索引遍历：<br>&emsp;&emsp;&emsp;&emsp;集合的索引的最小值是0，最大值是size-1;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.size()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;2.增强for循环遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object o : list)&#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;3.迭代器遍历：<br>&emsp;&emsp;&emsp;&emsp;iterator();能够和该集合相关的迭代器对象(Iterator接口，hasnext，next，remove)；<br>&emsp;&emsp;&emsp;&emsp;listIterator();能够获取和List集合相关的List集合特有的迭代器对象(ListIterator接口)<br>&emsp;&emsp;4.JDK8中的Lambda表达式遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List l = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//三种表示方法都一样，第三种最简Lambda表达式</span></span><br><span class="line">l.forEach((Object o)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">"+++"</span>+o);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">l.forEach((Object o)-&gt; System.out.println(o));</span><br><span class="line"></span><br><span class="line">l.forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="emsp-8-LinkList类：底层实现是双向链表"><a href="#emsp-8-LinkList类：底层实现是双向链表" class="headerlink" title="&emsp;8.LinkList类：底层实现是双向链表"></a>&emsp;<strong>8.LinkList类：底层实现是双向链表</strong></h2><p>&emsp;&emsp;该集合做元素的增加和删除比较快，做修改和查询比较慢<br>&emsp;&emsp;ArrayList集合由于底层实现是数组，所以增删比较慢，查询和修改比较快</p><h2 id="emsp-9-Set集合-接口-无序"><a href="#emsp-9-Set集合-接口-无序" class="headerlink" title="&emsp;9.Set集合(接口):无序"></a>&emsp;<strong>9.Set集合(接口):无序</strong></h2><p>&emsp;&emsp;Set集合无序(向集合中添加元素的顺序和取出元素的顺序不一致)并且不可重复，允许null值；Set集合底层的实现是Map集合的Key<br>&emsp;&emsp;1.Set接口：不支持索引操作的集合，没有特有方法<br>&emsp;&emsp;2.HashSet类：对应的底层的实现是HashMap的key，更底层的实现是哈希表：<br>&emsp;&emsp;&emsp;&emsp;增：add();<br>&emsp;&emsp;问：HashSet集合是如何保证元素不可重复的？<br>&emsp;&emsp;答：根据哈希值来判断向HashSet集合中添加的元素是否相同；先判断两个元素是否相同，如果哈希值不同，则是不同的元素，如果哈希值相同(哈希碰撞)，还要通过equals方法判断两个元素是否相等；如果自定义的的类型中重写了生成的哈希值的方法(hashCode方法)和equals方法，则按照重写的方法规则进行比较<br>&emsp;&emsp;如果要字定义重写类中的hashCode方法，最好重写equals方法，重写规则在hashCode方法中，由哪些数据参与产生了哈希值，就在equals方法中使用这些数据进行判断<br>&emsp;&emsp;&emsp;&emsp;删：remove();<br>&emsp;&emsp;&emsp;&emsp;改：直接修改对象的属性即可<br>&emsp;&emsp;&emsp;&emsp;查：迭代遍历查询<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.增强for循环<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.迭代器<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.Lambda表达式</p><h3 id="emsp-9-TreeSet类："><a href="#emsp-9-TreeSet类：" class="headerlink" title="&emsp;9.TreeSet类："></a>&emsp;<strong>9.TreeSet类：</strong></h3><p>&emsp;&emsp;是Set接口的实现类，直接底层实现是Map集合的Key值，底层的实现是二叉树(平衡二叉树/红黑树)，无序不可重复，但是该集合可以对自身存储的元素进行排序，排序依据的是Comparable接口中的ComparaTo方法，只能将实现了的Comparable接口的实现类的对象保存至TreeSet结合中</p><h4 id="1-Comparable接口：此接口让其自实现类具有自我排序性："><a href="#1-Comparable接口：此接口让其自实现类具有自我排序性：" class="headerlink" title="1.Comparable接口：此接口让其自实现类具有自我排序性："></a>1.Comparable接口：此接口让其自实现类具有自我排序性：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ComparaTo</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：int x = a.compareTo(b);</span></span><br><span class="line"><span class="comment">//x&gt;0 a大于b;</span></span><br><span class="line"><span class="comment">//x=0 a等于b;</span></span><br><span class="line"><span class="comment">//x&lt;b a小于b;</span></span><br></pre></td></tr></table></figure><h4 id="3-Comparator接口：此接口能够重写实现了Comparable接口的子实现类的排序规则"><a href="#3-Comparator接口：此接口能够重写实现了Comparable接口的子实现类的排序规则" class="headerlink" title="3.Comparator接口：此接口能够重写实现了Comparable接口的子实现类的排序规则"></a>3.Comparator<t>接口：此接口能够重写实现了Comparable接口的子实现类的排序规则</t></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">(T t1,T t2)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="4-TreeSet集合中不能添加不同引用类型的数据"><a href="#4-TreeSet集合中不能添加不同引用类型的数据" class="headerlink" title="4.TreeSet集合中不能添加不同引用类型的数据"></a>4.TreeSet集合中不能添加不同引用类型的数据</h4><h4 id="5-TreeSet集合保证元素不可重复的依据是Comparable接口中的CompareTo方法；"><a href="#5-TreeSet集合保证元素不可重复的依据是Comparable接口中的CompareTo方法；" class="headerlink" title="5.TreeSet集合保证元素不可重复的依据是Comparable接口中的CompareTo方法；"></a>5.TreeSet集合保证元素不可重复的依据是Comparable接口中的CompareTo方法；</h4><p>面试题：下面选项中哪些是类 A.B.D<br>A.ArrayList    B.HsahSet<br>C.SortedSet    D.AbstractSet</p><h3 id="emsp-10-Map集合："><a href="#emsp-10-Map集合：" class="headerlink" title="&emsp;10.Map集合："></a>&emsp;<strong>10.Map集合：</strong></h3><p>&emsp;&emsp;双列集合：结合中的元素是K，V成对出现的；Map集合的Key的特性与Set集合的特性完全一致，Map集合Value任意<br>&emsp;&emsp;&emsp;&emsp;1.增</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put(Key,Value);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;2.删</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove(key);<span class="comment">//在Map集合中移除指定的key对应的K,V键值对，并且返回value</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;3.改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">put(Key,Value);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;4.查<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1.将Map集合的所有的Key转化成Set集合(keySet()方法)，遍历Set集合获取每一个key，然后根据Key获取Map集合中对应的Value<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.(值集)将Map结合的所有的Value转化为Collection集合(values()方法)Map集合中不能更具Value获取Key<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.(键值集)将Map集合的所有元素转化成Set集合(entrySet()方法)，该Set集合中的每个元素都是Map.Entry()类型，Entry表示的是Map集合中的每一个键值对<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;4.Lambda表达式<br>&emsp;&emsp;&emsp;&emsp;5.HashMap:HsahSet对应，键可以为null<br>&emsp;&emsp;&emsp;&emsp;6.TreeMap:TreeSet对应，键不能为null</p><h3 id="emsp-11-Hashtable："><a href="#emsp-11-Hashtable：" class="headerlink" title="&emsp;11.Hashtable："></a>&emsp;<strong>11.Hashtable：</strong></h3><p>&emsp;&emsp;双列集合，线程安全的集合，键值都不能为null</p><h3 id="emsp-12-Properties类："><a href="#emsp-12-Properties类：" class="headerlink" title="&emsp;12.Properties类："></a>&emsp;<strong>12.Properties类：</strong></h3><p>&emsp;&emsp;双列集合，继承至HashTable&lt;Object,Object&gt;;此类常用于在程序中获取或者存储与该程序相关的配置信息</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;集合体系&quot;&gt;&lt;a href=&quot;#集合体系&quot; class=&quot;headerlink&quot; title=&quot;集合体系&quot;&gt;&lt;/a&gt;集合体系&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;font size&gt;&lt;/font&gt;&lt;br&gt;&lt;strong&gt;1.集合本身就是一个对象，用于存储其它对象；&lt;/strong&gt;&lt;br&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;2.集合中只能存储引用类型的数据，不能存储基本数据类型的数据；&lt;/strong&gt;&lt;/font&gt;&lt;br&gt;&lt;strong&gt;3.集合和数组一样，都可以理解为存储数据的容器;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;4.Collection集合：学顶层用底层;在单列体系中，Collectoin接口并不是最顶层接口,该接口有一个父接口：Iterable接口(单列集合的最顶层接口);&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
      <category term="集合" scheme="https://hudu-gugui.github.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
      <category term="高级编程" scheme="https://hudu-gugui.github.io/tags/%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Collection" scheme="https://hudu-gugui.github.io/tags/Collection/"/>
    
      <category term="Set集合" scheme="https://hudu-gugui.github.io/tags/Set%E9%9B%86%E5%90%88/"/>
    
      <category term="Map集合" scheme="https://hudu-gugui.github.io/tags/Map%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://hudu-gugui.github.io/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81.html"/>
    <id>https://hudu-gugui.github.io/字符编码.html</id>
    <published>2019-08-06T06:01:02.000Z</published>
    <updated>2019-08-10T04:20:42.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1></blockquote><p>Java语言对文本采用Unicode字符编码。由于计算机内存只能存取二进制数据，因此必须为各个字符进行编码。所谓编码就是指用一串二进制数据来表示特定的字符，常见的字符编码包括：</p><a id="more"></a><blockquote><h1 id="ASCAII字符编码"><a href="#ASCAII字符编码" class="headerlink" title="ASCAII字符编码"></a>ASCAII字符编码</h1></blockquote><p>ASCII–Amecian Standard Code for Information Interchange(美国信息交换标准代码). 主要用于表达现代英语西欧语言中的字符。它是现今最通用的三字节编码系统，他只用一个字节的七位，一共表示128个字符。</p><blockquote><h1 id="ISO-8859-1字符编码"><a href="#ISO-8859-1字符编码" class="headerlink" title="ISO-8859-1字符编码"></a>ISO-8859-1字符编码</h1></blockquote><p>又称为Latin-1，是国际标准化组织(ISO)为西欧语言中的字符定制的编码，用一个字节(8位)来为字符编码，与ASCII字符编码兼容。所谓兼容，是指对于相同的字符，它的ASCAII字符编码和ISO-88859-1字符编码相同。</p><blockquote><h1 id="GB2312字符编码"><a href="#GB2312字符编码" class="headerlink" title="GB2312字符编码"></a>GB2312字符编码</h1></blockquote><p>它包括对简体中文字符的编码，一共收录了7445个字符(6763个汉字+682个其它字符)它与ASCII字符编码兼容。</p><blockquote><h1 id="GBK字符编码"><a href="#GBK字符编码" class="headerlink" title="GBK字符编码"></a>GBK字符编码</h1></blockquote><p>对GB2312字符编码的扩展，收录了21886个字符(21003个字符+其它字符), 它与GB2312字符编码兼容。</p><blockquote><h1 id="Unicode字符编码："><a href="#Unicode字符编码：" class="headerlink" title="Unicode字符编码："></a>Unicode字符编码：</h1></blockquote><p>由国际Unicode协会编制，收录了全世界所有语言文字中的字符，是一种跨平台的字符编码。<br>UCS(Universal Character Set)是指采用Unicode字符编码的通用字符集。<br>Unicode具有两种编码方案：<br>. 用2个字节(16位)编码，被称为UCS-2, Java语言采用;<br>. 用4个字节(32位)编码，被称为UCS-4;</p><blockquote><h1 id="UTF字符编码"><a href="#UTF字符编码" class="headerlink" title="UTF字符编码"></a>UTF字符编码</h1><p>有些操作系统不完全支持16位或32位的Unicode字符编码，UTF(UCS Transformation Format)字符编码能够把Unicode字符编码转换为操作系统支持的编码，常见的UTF字符编码包括UTF-8, UTF-7和UTF-16.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;字符编码&quot;&gt;&lt;a href=&quot;#字符编码&quot; class=&quot;headerlink&quot; title=&quot;字符编码&quot;&gt;&lt;/a&gt;字符编码&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;Java语言对文本采用Unicode字符编码。由于计算机内存只能存取二进制数据，因此必须为各个字符进行编码。所谓编码就是指用一串二进制数据来表示特定的字符，常见的字符编码包括：&lt;/p&gt;
    
    </summary>
    
      <category term="编码" scheme="https://hudu-gugui.github.io/categories/%E7%BC%96%E7%A0%81/"/>
    
    
      <category term="ASCII" scheme="https://hudu-gugui.github.io/tags/ASCII/"/>
    
      <category term="ISO-8859-1" scheme="https://hudu-gugui.github.io/tags/ISO-8859-1/"/>
    
      <category term="GB2312" scheme="https://hudu-gugui.github.io/tags/GB2312/"/>
    
      <category term="GBK" scheme="https://hudu-gugui.github.io/tags/GBK/"/>
    
      <category term="Unicode" scheme="https://hudu-gugui.github.io/tags/Unicode/"/>
    
      <category term="UTF" scheme="https://hudu-gugui.github.io/tags/UTF/"/>
    
  </entry>
  
  <entry>
    <title>数据类型</title>
    <link href="https://hudu-gugui.github.io/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
    <id>https://hudu-gugui.github.io/数据类型.html</id>
    <published>2019-08-06T03:20:36.000Z</published>
    <updated>2019-08-11T02:42:52.380Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2></blockquote><p><img src="/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型"></p><p>booean:true或false，在JVM中会转换为0或1，1位<br>byte: 8位整数<br>short：16位整数<br>char：16位unicode字符<br>int：32位整数<br>float：32位浮点数<br>double：64位浮点数<br>long：64位整数</p><p>1字节 = 8bit</p><a id="more"></a><p>布尔类型：boolean<br>文本数据类型：char和String，<font color="red">String是一个类，不是基本数据类型</font><br>整数类型：byte、short、int、long<br>浮点数据类型：float、double</p><blockquote><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2></blockquote><p>类、接口、数组</p><blockquote><h2 id="char的几种可能取值"><a href="#char的几种可能取值" class="headerlink" title="char的几种可能取值"></a>char的几种可能取值</h2></blockquote><p>Java语言采用UCS-2字符编码，字符占2个字节。<br>字符a的二进制数据形式为 0000 0000 0110 0001<br>十六进制数据形式为 0x0061<br>十进制数据形式为 97</p><p>以下4种赋值方式是等价的：<br>           字符用单引号引着(英文输入法下面的单引号)<br>           字符串用双引号引着</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'\u0061'</span>;      <span class="comment">//设定"a"的十六进制数据的Unicode字符编码</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">0x0061</span>;        <span class="comment">//设定"a"的十六进制数据的Unicode字符编码</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="number">97</span>;            <span class="comment">//设定"a"的十进制数据的Unicode字符编码</span></span><br><span class="line"></span><br><span class="line">其他一些例子:</span><br><span class="line"><span class="keyword">char</span> a1 = <span class="string">'a'</span>;   <span class="comment">//一个字母</span></span><br><span class="line"><span class="keyword">char</span> a2 = <span class="string">'中'</span>;   <span class="comment">//一个中文字符</span></span><br><span class="line"><span class="keyword">char</span> a3 = <span class="string">'\u0060'</span>     <span class="comment">//unicode编码</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2></blockquote><p>Java编程人员在给字符变量赋值时，通常直接从键盘输入特定的字符，而不会使用Unicode字符编码，因为很难记住各种字符的Unicode字符编码值。<br>对于有些特殊字符，比如单引号，如不知道它的Unicode字符编码，直接从键盘输入编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">''</span><span class="string">';           //编码出错</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'\''</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'\\'</span>;</span><br></pre></td></tr></table></figure><p>转义字符以反斜杠开头，常用转义字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\n           换行符，将光标定位到下一行的开头；</span><br><span class="line">\t           垂直制表符，将光标移到下一个制表符的位置；</span><br><span class="line">\\           反斜杠字符</span><br><span class="line">\<span class="string">'           单引号字符</span></span><br><span class="line"><span class="string">\"           双引号字符</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="变量、声明和赋值"><a href="#变量、声明和赋值" class="headerlink" title="变量、声明和赋值"></a>变量、声明和赋值</h2></blockquote><p>程序的基本功能是处理数据<br>程序用变量来表示数据；<br>程序中必须先定义变量才能使用；<br>定义变量是指设定变量的数据类型和变量的名字，定义变量的基本语法为：<br>数据类型&emsp;变量名；<br>变量定义的注意事项：<br>&emsp;A：变量未赋值，不能直接使用<br>&emsp;B:变量只在它所属的范围内有效，变量属于它所在的大括号<br>&emsp;C：一行上可以定义多个变量，但是不建议<br>Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是指自从变量定义以后，首次给它赋初始<br>值的过程。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;          <span class="comment">//定义变量a</span></span><br><span class="line">a = <span class="number">1</span>;          <span class="comment">//初始化变量a</span></span><br><span class="line">a++;            <span class="comment">//使用变量a</span></span><br><span class="line"><span class="keyword">int</span> b=a;        <span class="comment">//定义变量b, 初始化变量b, 使用变量a的值;</span></span><br><span class="line">b++;            <span class="comment">//使用变量b</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2></blockquote><p><strong>(1)隐式类型转换：</strong><br>byte，short，char类型数据在进行算数运算时，会自动提升为int，其他类型运算时，表示范围小的会自动提升为大的，然后再运算<br>小类型可以直接赋值给大类型，类型自动转换为大的<br><strong>(2)显式类型转换</strong><br>赋值过程中，大类型赋值给小类型，会报错，出现精度损失，必须通过强制类型转换实现</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png&quot; alt=&quot;数据类型&quot;&gt;&lt;/p&gt;
&lt;p&gt;booean:true或false，在JVM中会转换为0或1，1位&lt;br&gt;byte: 8位整数&lt;br&gt;short：16位整数&lt;br&gt;char：16位unicode字符&lt;br&gt;int：32位整数&lt;br&gt;float：32位浮点数&lt;br&gt;double：64位浮点数&lt;br&gt;long：64位整数&lt;/p&gt;
&lt;p&gt;1字节 = 8bit&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="基本数据类型" scheme="https://hudu-gugui.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="引用数据类型" scheme="https://hudu-gugui.github.io/tags/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="类型转换" scheme="https://hudu-gugui.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Java标识、关键字、类型</title>
    <link href="https://hudu-gugui.github.io/Java%E6%A0%87%E8%AF%86%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E7%B1%BB%E5%9E%8B.html"/>
    <id>https://hudu-gugui.github.io/Java标识、关键字、类型.html</id>
    <published>2019-08-05T03:32:09.000Z</published>
    <updated>2019-08-06T03:19:18.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1></blockquote><p>用于解释说明性文字，作用：使用部分内容只为程序员可见，不为编译器所编译、虚拟机所执行。<br>&emsp;&emsp;单行注释：//注释文字<br>&emsp;&emsp;多行注释：/<em>注释文字</em>/<br>&emsp;&emsp;文档注释：/**注释文字/</p><p>其中文档注释，当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的成员方法的声明)之前时，会作为JavaDoc文档的内容；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span>类的作者</span><br><span class="line"><span class="meta">@version</span>类的版本</span><br><span class="line"><span class="meta">@param</span>方法的参数</span><br><span class="line"><span class="meta">@return</span>方法的返回类型</span><br><span class="line"><span class="meta">@exception</span>方法抛出的异常</span><br><span class="line"><span class="meta">@see</span>另外参照...</span><br><span class="line"><span class="meta">@since</span>从什么时候开始使用的</span><br></pre></td></tr></table></figure><a id="more"></a><p><font size="4">使用javadoc进行编译：</font><br><font color="pink">javadoc -d doc -author -version src/CommentTest.java</font><br><font size="4">或者：</font><br><font color="pink">javadoc -d doc -author -version src/*.java</font></p><blockquote><h1 id="分号、块、空格"><a href="#分号、块、空格" class="headerlink" title="分号、块、空格"></a>分号、块、空格</h1></blockquote><p>(1)每个语句短语以;结束<br>类的声明最后不需要加<br>方法的声明最后不需要加<br>属性的声明最后一定要加<br>(2)代码段以{}结束<br>常见的有：<br>    类的声明后加{}<br>    方法的声明后加{}<br>    注意:代码的{}后面都不加;<br>(3)空白处（空格、tab键、新行和回车（续航符））是无关紧要的。</p><blockquote><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1></blockquote><p>给类，接口，方法，变量名等起名字时使用的字符序列<br>英文大小写字母，数字字符，$和_。<br>不能使用关键字，不能数字开头，区分大小写。</p><blockquote><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1></blockquote><p>Java语言的关键字时程序代码中的特殊字符。包括：<br>类和接口的声明——class,extends,implements,interface<br>包引入和包声明——import,package<br>数据类型——boolean,byte,char,double,float,int,long,short<br>某些数据类型的可选值——false,true,null<br>流程控制——break,case,coutinue,default,do,else,for,return,switch,while<br>异常处理——catch.finally,throw,throws,try<br>修饰符——abstract,final,native,private,protected,public,static,synchronized,transient,colatile<br>操作符——instanceof<br>创建对象——new<br>引用——this,super<br>方法返回类型——void<br><font color="red">goto const(在java中不使用，但是保留为关键字)</font>严格地说，”true”和”false”不是关键字，它们时布尔类型值</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;用于解释说明性文字，作用：使用部分内容只为程序员可见，不为编译器所编译、虚拟机所执行。&lt;br&gt;&amp;emsp;&amp;emsp;单行注释：//注释文字&lt;br&gt;&amp;emsp;&amp;emsp;多行注释：/&lt;em&gt;注释文字&lt;/em&gt;/&lt;br&gt;&amp;emsp;&amp;emsp;文档注释：/**注释文字/&lt;/p&gt;
&lt;p&gt;其中文档注释，当这类注释出现在任何声明(如类的声明、类的成员变量的声明或者类的成员方法的声明)之前时，会作为JavaDoc文档的内容；&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@author&lt;/span&gt;		类的作者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@version&lt;/span&gt;	类的版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@param&lt;/span&gt;		方法的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@return&lt;/span&gt;		方法的返回类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@exception&lt;/span&gt;	方法抛出的异常&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@see&lt;/span&gt;		另外参照...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@since&lt;/span&gt;		从什么时候开始使用的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="标识" scheme="https://hudu-gugui.github.io/tags/%E6%A0%87%E8%AF%86/"/>
    
      <category term="关键字" scheme="https://hudu-gugui.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
      <category term="类型" scheme="https://hudu-gugui.github.io/tags/%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>初识Java</title>
    <link href="https://hudu-gugui.github.io/%E5%88%9D%E8%AF%86Java.html"/>
    <id>https://hudu-gugui.github.io/初识Java.html</id>
    <published>2019-08-01T13:57:57.000Z</published>
    <updated>2019-08-05T05:56:57.180Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="什么是Java？"><a href="#什么是Java？" class="headerlink" title="什么是Java？"></a>什么是Java？</h1></blockquote><p>&emsp;是编程语言<br>&emsp;开发环境：提供了一套应用程序的接口，解压rt.jar，解压src.zip查看源码<br>&emsp;应用程序环境<br>&emsp;并不仅仅是编程语言，而更准确地说是一个生态系统</p><blockquote><h1 id="为什么发明Java？"><a href="#为什么发明Java？" class="headerlink" title="为什么发明Java？"></a>为什么发明Java？</h1></blockquote><p><font size="4">1.提供了一套编译环境</font><br>&emsp;快速发展<br>&emsp;一次编写，到处运行，应用程序跨平台，中间层：给上层应用提供了一套API，针对不同的操作系统提供了JVM<br>&emsp;多线程，程序级别的多线程<br>&emsp;支持动态更新，其中一个发生了改变，这个编译后，其他的额能自动更新。<br><font size="4">2.提供了一个更简单的编程方法</font><br>&emsp;更健壮：没有指针，没有内存管理，面向对象编程<br><font size="4">3.如何实现上述目标的</font><br>&emsp;JVM，垃圾回收机制(Garbage Collection)，代码安全验证</p><a id="more"></a><blockquote><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1></blockquote><h2 id="Java基础分为三部分："><a href="#Java基础分为三部分：" class="headerlink" title="Java基础分为三部分："></a>Java基础分为三部分：</h2><p>&emsp;<font size="4">1.基础语法：</font>基本语句、流程控制<br>&emsp;<font size="4">2.编程思想：</font>面向对象，第一层：封装、继承、多态，第二层：怎么使用面向对象的思想去解决问题。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;第三层：现实问题的处理，如何使用面向对象解决现实问题。<br>&emsp;<font size="4">3.高级应用：</font>线程、网络、IO、XML解析。</p><blockquote><h1 id="Java代码安全"><a href="#Java代码安全" class="headerlink" title="Java代码安全"></a>Java代码安全</h1></blockquote><p><font size="5">Java程序执行流程</font><br>    &emsp;<font size="4">编辑，编译，类加载</font><br>    &emsp;<font size="4">类加载：</font>加载字节码文件<br>    &emsp;<font size="4">字节码验证：</font><br>        &emsp;&emsp;验证代码和虚拟机版本是否匹配，向下兼容<br>        &emsp;&emsp;代码不能破坏系统的完整性,也就是不能操作硬件<br>        &emsp;&emsp;无堆栈上溢和下溢<br>        &emsp;&emsp;参数类型是否正确<br>        &emsp;&emsp;类型转换是否正确<br>    &emsp;<font size="4">类加载器：</font><br>        &emsp;&emsp;1.启动类加载器：rt.jar<br>        &emsp;&emsp;2.扩展类加载器：jre/lib/ext/<br>        &emsp;&emsp;3.系统类加载器：自己的class<br>        &emsp;&emsp;4.网络类加载器：<br>        &emsp;<font size="4">双亲委托机制：</font>自顶向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Track myTrack = <span class="keyword">new</span> Track();             </span><br><span class="line">    myTrack.setTitle(<span class="string">"Watching The Wheels"</span>);</span><br><span class="line">    Duration myDuration = <span class="keyword">new</span> Duration(<span class="number">0</span>, <span class="number">3</span>, <span class="number">48</span>);</span><br><span class="line">    myTrack.setDuration(myDuration);</span><br><span class="line">    System.out.println(<span class="string">"myTrack is: "</span> + myTrack);   </span><br><span class="line">    System.out.println(<span class="string">"Title = "</span> + myTrack.getTitle());</span><br><span class="line">    System.out.println(<span class="string">"Duration = "</span> + myTrack.getDuration().toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;什么是Java？&quot;&gt;&lt;a href=&quot;#什么是Java？&quot; class=&quot;headerlink&quot; title=&quot;什么是Java？&quot;&gt;&lt;/a&gt;什么是Java？&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;emsp;是编程语言&lt;br&gt;&amp;emsp;开发环境：提供了一套应用程序的接口，解压rt.jar，解压src.zip查看源码&lt;br&gt;&amp;emsp;应用程序环境&lt;br&gt;&amp;emsp;并不仅仅是编程语言，而更准确地说是一个生态系统&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&quot;为什么发明Java？&quot;&gt;&lt;a href=&quot;#为什么发明Java？&quot; class=&quot;headerlink&quot; title=&quot;为什么发明Java？&quot;&gt;&lt;/a&gt;为什么发明Java？&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;font size=&quot;4&quot;&gt;1.提供了一套编译环境&lt;/font&gt;&lt;br&gt;&amp;emsp;快速发展&lt;br&gt;&amp;emsp;一次编写，到处运行，应用程序跨平台，中间层：给上层应用提供了一套API，针对不同的操作系统提供了JVM&lt;br&gt;&amp;emsp;多线程，程序级别的多线程&lt;br&gt;&amp;emsp;支持动态更新，其中一个发生了改变，这个编译后，其他的额能自动更新。&lt;br&gt;&lt;font size=&quot;4&quot;&gt;2.提供了一个更简单的编程方法&lt;/font&gt;&lt;br&gt;&amp;emsp;更健壮：没有指针，没有内存管理，面向对象编程&lt;br&gt;&lt;font size=&quot;4&quot;&gt;3.如何实现上述目标的&lt;/font&gt;&lt;br&gt;&amp;emsp;JVM，垃圾回收机制(Garbage Collection)，代码安全验证&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
      <category term="初识Java" scheme="https://hudu-gugui.github.io/categories/Java/%E5%88%9D%E8%AF%86Java/"/>
    
    
      <category term="JDK" scheme="https://hudu-gugui.github.io/tags/JDK/"/>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/tags/Java/"/>
    
      <category term="Java基础" scheme="https://hudu-gugui.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JDK、JRE、JVM解析</title>
    <link href="https://hudu-gugui.github.io/JDK%E3%80%81JRE%E3%80%81JVM%E8%A7%A3%E6%9E%90.html"/>
    <id>https://hudu-gugui.github.io/JDK、JRE、JVM解析.html</id>
    <published>2019-07-31T07:47:40.000Z</published>
    <updated>2019-08-01T13:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h4></blockquote><p><font color="red">指Java开发工具包</font>，包含了Java的开发工具：编译工具，打包工具运行等工具，如javac、java、javadoc等。</p><p>bin:&emsp;java的相关命令，如java  javac  jar  javadoc<br>db:&emsp;java提供的数据库<br>demo/sample:&emsp;java代码的一些示例<br>include:&emsp;C语言的头文件等内容<br>jre:&emsp;java的运行环境<br>lib:&emsp;java所用的基本的jar包</p><a id="more"></a><blockquote><h4 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h4></blockquote><p><font color="red">指Java运行环境</font>，包括JVM和Java的核心库类，如果想要运行一个开发好的应用，只需要安装JRE即可。</p><blockquote><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4></blockquote><p><font color="red">简称Java虚拟机(java virtual machine)</font>，是用软件来模拟一个虚拟的环境。</p><h5 id="Java虚拟机基本结构"><a href="#Java虚拟机基本结构" class="headerlink" title="Java虚拟机基本结构"></a>Java虚拟机基本结构</h5><p><img src="/images/JVM.png" alt="JVM"></p><h5 id="Java运行基本过程："><a href="#Java运行基本过程：" class="headerlink" title="Java运行基本过程："></a>Java运行基本过程：</h5><p>编写.java文件—&gt;编译为.class文件—&gt;类加载–&gt;字节码验证–&gt;JIT运行<br>字节码验证的内容:<br>&emsp;代码要符合JVM的规范<br>&emsp;代码破坏计算机的系统或者硬件<br>&emsp;栈不能溢出<br>&emsp;方法的参数类型要正确<br>&emsp;类型转换要正确</p><h5 id="类加载"><a href="#类加载" class="headerlink" title="类加载:"></a>类加载:</h5><p>双亲委托机制<br>把我们写好并编译成的.class字节码文件从硬盘中加载到内存</p><h5 id="JVM使用类加载器来完成类加载的过程"><a href="#JVM使用类加载器来完成类加载的过程" class="headerlink" title="JVM使用类加载器来完成类加载的过程"></a>JVM使用类加载器来完成类加载的过程</h5><p>类加载器有:<br>类装载器：（分为4步）1》2》3》4<br>&emsp;1、启动类装载器：bootstrap class loader<br>&emsp;&emsp;&emsp;&emsp;从jdk的安装目录下  jdk/jre/lib/rt.jar<br>&emsp;&emsp;&emsp;&emsp;rt.jar 是个包，放的是Java作为开发环境的所有的库<br>&emsp;2、扩展类装载器：extensible class loader<br>&emsp;&emsp;&emsp;&emsp;从jdk的安装目录下 jdk/jre/lib/ext/*.jar<br>&emsp;&emsp;&emsp;&emsp;jdk下的所有的.jar 文件<br>&emsp;3、系统类装载器：system class loader<br>&emsp;&emsp;&emsp;&emsp;$CLASSPATH<br>&emsp;&emsp;&emsp;&emsp;你所配置的classpath<br>&emsp;4、网络类装载器：network class loader<br>类加载器:从一个指定路径下面去加载代码运行时需要用到的java类</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;指Java开发工具包&lt;/font&gt;，包含了Java的开发工具：编译工具，打包工具运行等工具，如javac、java、javadoc等。&lt;/p&gt;
&lt;p&gt;bin:&amp;emsp;java的相关命令，如java  javac  jar  javadoc&lt;br&gt;db:&amp;emsp;java提供的数据库&lt;br&gt;demo/sample:&amp;emsp;java代码的一些示例&lt;br&gt;include:&amp;emsp;C语言的头文件等内容&lt;br&gt;jre:&amp;emsp;java的运行环境&lt;br&gt;lib:&amp;emsp;java所用的基本的jar包&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="JDK" scheme="https://hudu-gugui.github.io/tags/JDK/"/>
    
      <category term="JRE" scheme="https://hudu-gugui.github.io/tags/JRE/"/>
    
      <category term="JVM" scheme="https://hudu-gugui.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java环境变量配置</title>
    <link href="https://hudu-gugui.github.io/Java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE.html"/>
    <id>https://hudu-gugui.github.io/Java环境变量配置.html</id>
    <published>2019-07-31T06:54:15.000Z</published>
    <updated>2019-08-05T03:22:19.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="Java-HOME"><a href="#Java-HOME" class="headerlink" title="Java_HOME"></a>Java_HOME</h3></blockquote><p>在下方的【系统变量】中，并不存在JAVA_HOME变量,那么我们需要点击【新建】<br>windows:<br>   JAVA_HOME:JDK安装的目录路径<br>   <font color="red">例：D:\Java\jdk1.8.0_151</font></p><p><img src="/images/JAVA_HOME.png" alt="JAVA_HOME"></p><p>用JAVA写的软件都需要本地JDK的支持，它回去找本地配的JAVA_HOME，很多时候是给第三方用的，比如maven，tomcat，hadoop。</p><a id="more"></a><blockquote><h3 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h3></blockquote><p>class文件、jar包 的搜索路径。保存的是一些目录和jar文件的地址，这些路径是为java程序在编译和运行时搜索类而用的，为java程序所依赖的接口、类指定一个搜索路径。<font color="red">一般不需要配置，默认值为.当前目录。</font> </p><blockquote><h3 id="PATh"><a href="#PATh" class="headerlink" title="PATh"></a>PATh</h3></blockquote><p>在cmd终端运行dos命令时命令对应一个特定功能，特定功能由对应应用程序实现，PATH里面存放命令的搜索路径。JDK安装目录里面的命令目录。</p><p>同样是在【系统变量中】我们可以看到path变量已经存在，那么我们只需要点击【编辑】，进入path变量的编辑</p><p><img src="/images/PATH1.png" alt="PATH"></p><p>变量名不变，变量值改为【%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;】，最后点击确定。</p><p><img src="/images/PATH2.png" alt="PATH"></p><blockquote><h3 id="测试环境是否配置成功"><a href="#测试环境是否配置成功" class="headerlink" title="测试环境是否配置成功"></a>测试环境是否配置成功</h3></blockquote><p>使用<kbd>Win</kbd>+<kbd>R</kbd> 输入cmd<br>在新打开的命令窗口中输入命令:java或者javac 后看到相应的信息提示即可.<br>  java -version<br><img src="/images/java-version.png" alt="PATH"></p><blockquote><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3></blockquote><p><font color size="4">rt.jar是JAVA基础类库，dt.jar是关于运行环境的类库，tools.jar是工具类库</font><br><font size="4">(1)rt.jar</font><br>&emsp;默认就在Root Classloader的加载路径里面的，而在Claspath配置该变量是不需要的；同时jre/lib目录下的其他jar:jce.jar、jsse.jar、charsets.jar、resources.jar都在Root Classloader中<br><font size="4">(2)tools.jar </font><br>&emsp;是系统用来编译一个类的时候用到的，即执行javac的时候用到javac XXX.java，实际上就是运行 <font color="pink">java -Calsspath=%JAVA_HOME%\lib\tools.jar&emsp;xx.xxx.Main XXX.java</font>，javac就是对上面命令的封装，所以tools.jar也不用加到classpath里面<br><font size="4">(3)dt.jar</font><br>&emsp;是关于运行环境的类库,主要是swing的包，在用到swing时最好加上</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;Java-HOME&quot;&gt;&lt;a href=&quot;#Java-HOME&quot; class=&quot;headerlink&quot; title=&quot;Java_HOME&quot;&gt;&lt;/a&gt;Java_HOME&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在下方的【系统变量】中，并不存在JAVA_HOME变量,那么我们需要点击【新建】&lt;br&gt;windows:&lt;br&gt;   JAVA_HOME:JDK安装的目录路径&lt;br&gt;   &lt;font color=&quot;red&quot;&gt;例：D:\Java\jdk1.8.0_151&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/JAVA_HOME.png&quot; alt=&quot;JAVA_HOME&quot;&gt;&lt;/p&gt;
&lt;p&gt;用JAVA写的软件都需要本地JDK的支持，它回去找本地配的JAVA_HOME，很多时候是给第三方用的，比如maven，tomcat，hadoop。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
      <category term="Java环境配置" scheme="https://hudu-gugui.github.io/categories/Java/Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Java环境" scheme="https://hudu-gugui.github.io/tags/Java%E7%8E%AF%E5%A2%83/"/>
    
      <category term="JDK" scheme="https://hudu-gugui.github.io/tags/JDK/"/>
    
      <category term="JRE" scheme="https://hudu-gugui.github.io/tags/JRE/"/>
    
  </entry>
  
  <entry>
    <title>Java学习</title>
    <link href="https://hudu-gugui.github.io/Java%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://hudu-gugui.github.io/Java学习.html</id>
    <published>2019-07-30T01:02:04.000Z</published>
    <updated>2019-07-30T07:25:13.000Z</updated>
    
    <content type="html"><![CDATA[<!-- <iframe width="100%" height="560" src="//player.bilibili.com/player.html?aid=41949084&cid=75021374&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe> --><p><a href="https://www.bilibili.com/" target="_blank" rel="noopener">哔哩哔哩</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="110" src="//music.163.com/outchain/player?type=4&id=334309073&auto=0&height=90"></iframe><a id="more"></a><p><img src="/images/2.jpg" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- &lt;iframe width=&quot;100%&quot; height=&quot;560&quot; src=&quot;//player.bilibili.com/player.html?aid=41949084&amp;cid=75021374&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; --&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;哔哩哔哩&lt;/a&gt;&lt;/p&gt;
&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;110&quot; src=&quot;//music.163.com/outchain/player?type=4&amp;id=334309073&amp;auto=0&amp;height=90&quot;&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
      <category term="初识Java" scheme="https://hudu-gugui.github.io/categories/Java/%E5%88%9D%E8%AF%86Java/"/>
    
    
      <category term="Java" scheme="https://hudu-gugui.github.io/tags/Java/"/>
    
      <category term="Java基础" scheme="https://hudu-gugui.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>

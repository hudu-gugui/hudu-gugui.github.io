<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HuDu&#39;Blog</title>
  
  <subtitle>Make ardous efforts</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hudu-gugui.github.io/"/>
  <updated>2019-11-28T03:31:10.680Z</updated>
  <id>https://hudu-gugui.github.io/</id>
  
  <author>
    <name>HuDu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql密码及权限修改</title>
    <link href="https://hudu-gugui.github.io/mysql%E5%AF%86%E7%A0%81%E5%8F%8A%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9.html"/>
    <id>https://hudu-gugui.github.io/mysql密码及权限修改.html</id>
    <published>2019-11-28T03:02:31.000Z</published>
    <updated>2019-11-28T03:31:10.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改Mysql数据密码"><a href="#修改Mysql数据密码" class="headerlink" title="修改Mysql数据密码"></a>修改Mysql数据密码</h1><h2 id="用set-password命令"><a href="#用set-password命令" class="headerlink" title="用set password命令"></a>用set password命令</h2><p>格式：mysql&gt; set password for 用户名@localhost=password(‘新密码’);<br>例子：mysql&gt; set password for root@localhost=passrord(‘123’);</p><h2 id="使用mysqladmin"><a href="#使用mysqladmin" class="headerlink" title="使用mysqladmin"></a>使用mysqladmin</h2><p>格式：mysqladmin -u用户名 -p旧密码 password 新密码<br>例子：mysqladmin -uroot -p123456 password 123</p><h2 id="使用update直接编辑user表"><a href="#使用update直接编辑user表" class="headerlink" title="使用update直接编辑user表"></a>使用update直接编辑user表</h2><a id="more"></a><p>mysql&gt; uer mysql;</p><p>user表字段说明：<br><img src="/images/Mysql/user%E8%A1%A8.png" alt="user表"></p><p>第一行表示的是本地访问数据库的root用户的密码<br>第二行表示远程连接数据库的用户名密码</p><p>mysql&gt; update user set password=password(“123”) where user=’root’ and localhost=’localhost’;</p><p>mysql&gt; flush privileges;</p><ul><li><p>最后一步不能少，作用是重启mysql服务器，使更新的密码生效</p></li><li><p>注意：5.7版本下的mysql数据库下已经没有password这个字段了，password字段改成了authentication_string。</p></li></ul><h2 id="忘记root密码时"><a href="#忘记root密码时" class="headerlink" title="忘记root密码时"></a>忘记root密码时</h2><p>以windows为例<br>1.关闭mysql服务</p><p>2.打开DOS窗口，转到mysql\bin目录。</p><p>3.输入mysql –skip-grant-tables回车。–skip-grant-tables的意思时启动Mysql服务器的时候跳过权限认证。</p><p>4.再开一个DOS窗口(刚才的DOS窗口已经不能动了)，转到mysql\bin目录。</p><p>5.输入mysql 回车，如果成功，出现Mysql提示符&gt;。</p><p>6.连接数据库：use mysql;,修改密码：update user set password=password(“123”) where user=’root’;</p><p>7.刷新权限：flush privileges;。</p><p>8.再次登录，mysql -uroot -p然后输入密码</p><h1 id="mysql数据库赋权限-DCL操作"><a href="#mysql数据库赋权限-DCL操作" class="headerlink" title="mysql数据库赋权限(DCL操作)"></a>mysql数据库赋权限(DCL操作)</h1><h2 id="给用户赋予权限"><a href="#给用户赋予权限" class="headerlink" title="给用户赋予权限"></a>给用户赋予权限</h2><p>格式：grant 权限1，权限2…(或 all privileges) on 数据库名.表名 to 用户名@用户地址 identified by ‘连接口令’</p><p>例如：grant select,insert,updata,create,drop on test.employee to joe@’10.163.255.87’ identified by ‘123’;</p><p>flush privilages;</p><p>给来自10.163.225.87的用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。</p><p>mysql&gt;grant  all  privileges  on   <em>.</em>   to   joe@’10.163.255.87’  identified  by  ‘123’;</p><p>mysql&gt;flush privileges;</p><h2 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h2><p>revoke all privileges on <em>.</em> from user_name@”ip”;</p><p>flush privileges;</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;修改Mysql数据密码&quot;&gt;&lt;a href=&quot;#修改Mysql数据密码&quot; class=&quot;headerlink&quot; title=&quot;修改Mysql数据密码&quot;&gt;&lt;/a&gt;修改Mysql数据密码&lt;/h1&gt;&lt;h2 id=&quot;用set-password命令&quot;&gt;&lt;a href=&quot;#用set-password命令&quot; class=&quot;headerlink&quot; title=&quot;用set password命令&quot;&gt;&lt;/a&gt;用set password命令&lt;/h2&gt;&lt;p&gt;格式：mysql&amp;gt; set password for 用户名@localhost=password(‘新密码’);&lt;br&gt;例子：mysql&amp;gt; set password for root@localhost=passrord(‘123’);&lt;/p&gt;
&lt;h2 id=&quot;使用mysqladmin&quot;&gt;&lt;a href=&quot;#使用mysqladmin&quot; class=&quot;headerlink&quot; title=&quot;使用mysqladmin&quot;&gt;&lt;/a&gt;使用mysqladmin&lt;/h2&gt;&lt;p&gt;格式：mysqladmin -u用户名 -p旧密码 password 新密码&lt;br&gt;例子：mysqladmin -uroot -p123456 password 123&lt;/p&gt;
&lt;h2 id=&quot;使用update直接编辑user表&quot;&gt;&lt;a href=&quot;#使用update直接编辑user表&quot; class=&quot;headerlink&quot; title=&quot;使用update直接编辑user表&quot;&gt;&lt;/a&gt;使用update直接编辑user表&lt;/h2&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://hudu-gugui.github.io/categories/Mysql/"/>
    
    
      <category term="权限修改" scheme="https://hudu-gugui.github.io/tags/%E6%9D%83%E9%99%90%E4%BF%AE%E6%94%B9/"/>
    
      <category term="密码修改" scheme="https://hudu-gugui.github.io/tags/%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>Spark</title>
    <link href="https://hudu-gugui.github.io/Spark.html"/>
    <id>https://hudu-gugui.github.io/Spark.html</id>
    <published>2019-11-28T02:49:33.000Z</published>
    <updated>2019-11-28T02:50:31.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;环境配置&quot;&gt;&lt;a href=&quot;#环境配置&quot; class=&quot;headerlink&quot; title=&quot;环境配置&quot;&gt;&lt;/a&gt;环境配置&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Spark" scheme="https://hudu-gugui.github.io/categories/Spark/"/>
    
    
      <category term="环境配置" scheme="https://hudu-gugui.github.io/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
      <category term="WordCount" scheme="https://hudu-gugui.github.io/tags/WordCount/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序</title>
    <link href="https://hudu-gugui.github.io/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F.html"/>
    <id>https://hudu-gugui.github.io/微信小程序.html</id>
    <published>2019-11-27T11:35:50.000Z</published>
    <updated>2019-11-27T11:58:40.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每个页面的作用"><a href="#每个页面的作用" class="headerlink" title="每个页面的作用"></a>每个页面的作用</h1><p>app.json 全局配置文件</p><h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><p>pages:所有的页面<br>可以通过增加pages来自动创建页面</p><p>window字段：<br>navigationBarBackgroundColor：导航栏颜色<br>navigationBarTitleText：导航栏标题<br>navigationBarTextStyle：导航栏颜色<br>其它具体官网了解</p><p>tabBar：底部按钮</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;每个页面的作用&quot;&gt;&lt;a href=&quot;#每个页面的作用&quot; class=&quot;headerlink&quot; title=&quot;每个页面的作用&quot;&gt;&lt;/a&gt;每个页面的作用&lt;/h1&gt;&lt;p&gt;app.json 全局配置文件&lt;/p&gt;
&lt;h2 id=&quot;字段说明&quot;&gt;&lt;a href=&quot;#字段说明&quot; 
      
    
    </summary>
    
      <category term="微信小程序" scheme="https://hudu-gugui.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="页面" scheme="https://hudu-gugui.github.io/tags/%E9%A1%B5%E9%9D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Scala之表达式</title>
    <link href="https://hudu-gugui.github.io/Scala%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>https://hudu-gugui.github.io/Scala之表达式.html</id>
    <published>2019-11-27T02:00:58.000Z</published>
    <updated>2019-11-27T03:27:47.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ifTest</span></span>(i:<span class="type">Int</span>)=&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">10</span>)&#123;</span><br><span class="line">      i</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">10</span>) &#123;</span><br><span class="line">      i+<span class="number">10</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forTest</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//to [1,10]</span></span><br><span class="line">    <span class="comment">//until [1,10)</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> until <span class="number">10</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//守卫，在for中添加if</span></span><br><span class="line">    <span class="keyword">for</span> (i&lt;<span class="number">-1</span> to <span class="number">10</span>) <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加多个守卫,分号隔开</span></span><br><span class="line">    <span class="keyword">for</span> (i&lt;<span class="number">-1</span> to <span class="number">10</span>;<span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>);<span class="keyword">if</span>(i!=<span class="number">2</span>)) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//嵌套循环</span></span><br><span class="line">    <span class="keyword">for</span> (i&lt;- <span class="number">1</span> to <span class="number">5</span>;j&lt;<span class="number">-5</span> to <span class="number">10</span>) &#123;</span><br><span class="line">      println(i+<span class="string">" "</span>+j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间[1,10)</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="type">Range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)) &#123;</span><br><span class="line">      println(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;if表达式&quot;&gt;&lt;a href=&quot;#if表达式&quot; class=&quot;headerlink&quot; title=&quot;if表达式&quot;&gt;&lt;/a&gt;if表达式&lt;/h1&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ifTest&lt;/span&gt;&lt;/span&gt;(i:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i==&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      i+&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Scala" scheme="https://hudu-gugui.github.io/categories/Scala/"/>
    
    
      <category term="if表达式" scheme="https://hudu-gugui.github.io/tags/if%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="for" scheme="https://hudu-gugui.github.io/tags/for/"/>
    
      <category term="模式匹配" scheme="https://hudu-gugui.github.io/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="https://hudu-gugui.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html"/>
    <id>https://hudu-gugui.github.io/排序算法.html</id>
    <published>2019-09-17T02:03:45.000Z</published>
    <updated>2019-11-27T02:56:33.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序也成为排序算法，排序是将一组数据，依指定的顺序进行排列的过程</p><h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><ul><li>1.内部排序：指将需要处理的所有数据都假造到内部存储器中进行排序</li><li>2.外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储(文件)进行排序</li><li>常见的排序算法分类见下图：</li></ul><p><img src="/images/Sort_Algorithm/%E6%8E%92%E5%BA%8F.png" alt="常见排序分类"></p><a id="more"></a><h1 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h1><h2 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h2><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)</p><p>举例说明：<br><img src="/images/Sort_Algorithm/1-1.png" alt></p><p><strong>时间复杂度忽略常数项</strong></p><h1 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h1><h2 id="常数阶"><a href="#常数阶" class="headerlink" title="常数阶"></a>常数阶</h2><h2 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h2><h2 id="线性阶"><a href="#线性阶" class="headerlink" title="线性阶"></a>线性阶</h2><h2 id="线性对数阶"><a href="#线性对数阶" class="headerlink" title="线性对数阶"></a>线性对数阶</h2><h2 id="平方阶"><a href="#平方阶" class="headerlink" title="平方阶"></a>平方阶</h2><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>思路：<br>第一轮从第一个数开始，比较相邻的两个数，如果前面大于后面，进行交换，否则不变，第一轮下来，排好最大的数，放在数组的最后。<br>依次进行上面的步骤，若数组长度为n，则最多进行n-1轮排序，即可得到有序的数组</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>思路：第一轮排序，假定第一个数为最小数，然后依次和后面的数进行比较，最后得到最小的数和最小数的下标，进行交换<br>然后下面同样重复上面的步骤，如果数组长度为n，则最多只需进行n-1轮比较</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>思路：把n个待排序的元素看成一个有序表和一个无序表，开始的时候，有序表中只包含一个元素，无序表中含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较，将它插入到有序表中适当位置，使之成为新的有序表</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序(DonldShell)于1959年提出的一种排序算法，希尔排序也是一种插入排序，他是简单插入排序经过改进之后的更高效的版本，也称为缩小增量排序。</p><p><strong>基本思想</strong><br>希尔排序时把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减少至1时，整个文件恰被分成一组，算法便终止</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;排序也成为排序算法，排序是将一组数据，依指定的顺序进行排列的过程&lt;/p&gt;
&lt;h2 id=&quot;排序的分类&quot;&gt;&lt;a href=&quot;#排序的分类&quot; class=&quot;headerlink&quot; title=&quot;排序的分类&quot;&gt;&lt;/a&gt;排序的分类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.内部排序：指将需要处理的所有数据都假造到内部存储器中进行排序&lt;/li&gt;
&lt;li&gt;2.外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储(文件)进行排序&lt;/li&gt;
&lt;li&gt;常见的排序算法分类见下图：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/Sort_Algorithm/%E6%8E%92%E5%BA%8F.png&quot; alt=&quot;常见排序分类&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="算法" scheme="https://hudu-gugui.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://hudu-gugui.github.io/%E9%80%92%E5%BD%92.html"/>
    <id>https://hudu-gugui.github.io/递归.html</id>
    <published>2019-09-16T02:11:36.000Z</published>
    <updated>2019-11-27T02:56:00.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂问题，同时让代码变得简洁。</p><h2 id="递归调用规则"><a href="#递归调用规则" class="headerlink" title="递归调用规则"></a>递归调用规则</h2><ul><li>1.当程序执行到一个方法时，就会开辟一个独立的空间(栈)。</li><li>2.每个空间的数据(局部变量),是独立的。</li></ul><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;<span class="number">2</span>) &#123;</span><br><span class="line">            test(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"n="</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/images/Recursion/RecursionTest.png" alt="递归调用规则"></p><p>StackOverflowError</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;递归的概念&quot;&gt;&lt;a href=&quot;#递归的概念&quot; class=&quot;headerlink&quot; title=&quot;递归的概念&quot;&gt;&lt;/a&gt;递归的概念&lt;/h2&gt;&lt;p&gt;简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂问题，同时让代码变得简洁。&lt;/p&gt;
&lt;h2 id=&quot;递归调用规则&quot;&gt;&lt;a href=&quot;#递归调用规则&quot; class=&quot;headerlink&quot; title=&quot;递归调用规则&quot;&gt;&lt;/a&gt;递归调用规则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.当程序执行到一个方法时，就会开辟一个独立的空间(栈)。&lt;/li&gt;
&lt;li&gt;2.每个空间的数据(局部变量),是独立的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;代码示例&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RecursionTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        test(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            test(n-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;n=&quot;&lt;/span&gt;+n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java数据结构" scheme="https://hudu-gugui.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="递归" scheme="https://hudu-gugui.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>前缀、中缀、后缀(逆波兰表达式)</title>
    <link href="https://hudu-gugui.github.io/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>https://hudu-gugui.github.io/前缀、中缀、后缀-逆波兰表达式.html</id>
    <published>2019-09-12T01:43:07.000Z</published>
    <updated>2019-11-27T03:27:40.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h1><ul><li>前缀表达式又称为波兰式，前缀表达式的运算符位于操作数前</li><li>举例说明：(3+4)X5-6(中缀表达式)对应的前缀表达式就是-X+3456</li></ul><h1 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h1><ul><li>中缀表达式就是常见的运算表达式、如(3+4)X5-5</li><li>中缀表达式的求值是我们最熟悉的，但是对计算机来说去不好操作，因此在计算结果时，往往会将中缀表达式转成其他表达式来操作(一般转成后缀表达式)</li></ul><a id="more"></a><h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><ul><li>后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后</li><li>举例：(3+4)X5-6对应的后缀表达式就是34+5X6-</li><li>再比如：</li></ul><p>中缀表达式转后缀表达式</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前缀表达式&quot;&gt;&lt;a href=&quot;#前缀表达式&quot; class=&quot;headerlink&quot; title=&quot;前缀表达式&quot;&gt;&lt;/a&gt;前缀表达式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;前缀表达式又称为波兰式，前缀表达式的运算符位于操作数前&lt;/li&gt;
&lt;li&gt;举例说明：(3+4)X5-6(中缀表达式)对应的前缀表达式就是-X+3456&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;中缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式&quot;&gt;&lt;/a&gt;中缀表达式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;中缀表达式就是常见的运算表达式、如(3+4)X5-5&lt;/li&gt;
&lt;li&gt;中缀表达式的求值是我们最熟悉的，但是对计算机来说去不好操作，因此在计算结果时，往往会将中缀表达式转成其他表达式来操作(一般转成后缀表达式)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java数据结构" scheme="https://hudu-gugui.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://hudu-gugui.github.io/%E9%93%BE%E8%A1%A8.html"/>
    <id>https://hudu-gugui.github.io/链表.html</id>
    <published>2019-09-09T10:41:25.000Z</published>
    <updated>2019-09-11T10:53:17.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>1.链表是以节点的方式存储</li><li>2.每个节点包含data域(保存数据),next域：指向下一个节点</li><li>3.如同：发现链表的各个节点不一定是连续存储</li><li>4.链表分为带头节点的链表和没有头节点的链表，根据实际的需求来确定</li></ul><p><img src="/images/Linked_List/1-1.png" alt="链表"></p><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>一、添加(创建)head节点：</p><ul><li>1.不存放具体的数据</li><li>2.作用就是表示单链表的头<br>二、后面我们每添加一个节点，就直接加入到链表的最后</li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">        HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">        HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">        HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建要给链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line">        <span class="comment">//显示</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个SingleLinkedList管理我们的数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先初始化一个头节点，头节点不要动，不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//添加节点到单向链表</span></span><br><span class="line">    <span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">//1.找到前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后这个节点的next指向新的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到,就将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就执向了链表的最后</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表[遍历]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否是链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将next后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode,每一个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写toString</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode&#123;"</span> +</span><br><span class="line">                <span class="string">"no="</span> + no +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", nickname='"</span> + nickname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Linked_List/2-1.png" alt="运行结果"></p><h2 id="按照比好的顺序添加"><a href="#按照比好的顺序添加" class="headerlink" title="按照比好的顺序添加"></a>按照比好的顺序添加</h2><ul><li>1.首先找到新的节点的位置，是通过辅助</li></ul><h2 id="从链表中删除一个节点的思路"><a href="#从链表中删除一个节点的思路" class="headerlink" title="从链表中删除一个节点的思路"></a>从链表中删除一个节点的思路</h2><ul><li>1.我们先找到需要删除的这个节点的前一个节点temp</li><li>2.temp.next = temp.next.next</li><li>被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</li></ul><p><strong>链表常见的面试题</strong></p><ul><li>1求单链表中有效节点的个数</li><li>2.查找单链表中倒数第k个节点</li><li>3.从尾到头打印单链表</li><li>4.合并两个有序的单链表，合并之后的链表依然有序</li></ul><h2 id="单项环形链表"><a href="#单项环形链表" class="headerlink" title="单项环形链表"></a>单项环形链表</h2><p><strong>Josephu(约瑟夫、约瑟夫环)问题</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.链表是以节点的方式存储&lt;/li&gt;
&lt;li&gt;2.每个节点包含data域(保存数据),next域：指向下一个节点&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java数据结构" scheme="https://hudu-gugui.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://hudu-gugui.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列</title>
    <link href="https://hudu-gugui.github.io/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97.html"/>
    <id>https://hudu-gugui.github.io/稀疏数组和队列.html</id>
    <published>2019-09-06T07:09:40.000Z</published>
    <updated>2019-09-06T07:20:19.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="稀疏-sparsearry-数组"><a href="#稀疏-sparsearry-数组" class="headerlink" title="稀疏(sparsearry)数组"></a>稀疏(sparsearry)数组</h1><h2 id="实际需求"><a href="#实际需求" class="headerlink" title="实际需求"></a>实际需求</h2><p><img src="/images/Algorithm/sparsearray/1-1.png" alt="五子棋"></p><a id="more"></a><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul><li>队列是一个有序列表，可以用数组或是链表来实现</li><li>遵循先入先出的原则，即：先存入的数据，要取出来，后存入的要后取出来</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;稀疏-sparsearry-数组&quot;&gt;&lt;a href=&quot;#稀疏-sparsearry-数组&quot; class=&quot;headerlink&quot; title=&quot;稀疏(sparsearry)数组&quot;&gt;&lt;/a&gt;稀疏(sparsearry)数组&lt;/h1&gt;&lt;h2 id=&quot;实际需求&quot;&gt;&lt;a href=&quot;#实际需求&quot; class=&quot;headerlink&quot; title=&quot;实际需求&quot;&gt;&lt;/a&gt;实际需求&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/Algorithm/sparsearray/1-1.png&quot; alt=&quot;五子棋&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="sparsearray" scheme="https://hudu-gugui.github.io/categories/sparsearray/"/>
    
    
      <category term="稀疏数组" scheme="https://hudu-gugui.github.io/tags/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
    
      <category term="队列" scheme="https://hudu-gugui.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java数据结构和算法</title>
    <link href="https://hudu-gugui.github.io/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.html"/>
    <id>https://hudu-gugui.github.io/Java数据结构和算法.html</id>
    <published>2019-09-05T10:48:56.000Z</published>
    <updated>2019-09-06T07:08:59.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p><strong>字符串匹配问题</strong></p><p>一个字符串，要判断另一个字符串中是否存在此字符串，要求用最快的速度来匹配。</p><ul><li>暴力匹配(简单，但是效率低)</li><li>KMP算法《部分匹配表》</li></ul><a id="more"></a><p><strong>汉诺塔</strong></p><p>分支算法</p><p><strong>八皇后问题</strong></p><p>回溯算法</p><p><strong>马踏棋盘</strong></p><p>图形的深度优先遍历算法(DFS)+贪心算法优化</p><h1 id="数据结构与算法的概述"><a href="#数据结构与算法的概述" class="headerlink" title="数据结构与算法的概述"></a>数据结构与算法的概述</h1><h2 id="数据结构和算法的关系"><a href="#数据结构和算法的关系" class="headerlink" title="数据结构和算法的关系"></a>数据结构和算法的关系</h2><ul><li>数据data结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构.学好数据结构可以编写出更加漂亮,更加有效率的代码。</li><li>要学习好数据结构就要多多考虑如何将生活中遇到的问题,用程序去实现解决.</li><li>程序 = 数据结构 + 算法</li><li>数据结构是算法的基础, 换言之，想要学好算法，需要把数据结构学到位。</li></ul><h2 id="实际编程中的问题"><a href="#实际编程中的问题" class="headerlink" title="实际编程中的问题"></a>实际编程中的问题</h2><h3 id="字符串替换问题"><a href="#字符串替换问题" class="headerlink" title="字符串替换问题"></a>字符串替换问题</h3><p><img src="/images/Algorithm/%E5%AE%9E%E4%BE%8B1-1.png" alt></p><p>小结：需要用到单链表数据结构</p><h3 id="一个五子棋程序"><a href="#一个五子棋程序" class="headerlink" title="一个五子棋程序"></a>一个五子棋程序</h3><p><img src="/images/Algorithm/%E5%AE%9E%E4%BE%8B1-2.png" alt></p><p>如何判断游戏的输赢，并可以完成存盘退出和继续上局的功能</p><ul><li>1) 棋盘 二维数组=&gt;( 稀疏数组)-&gt; 写入文件 【存档功能】</li><li>2) 读取文件-》稀疏数组-》二维数组 -》 棋盘 【接上局】</li></ul><h2 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h2><p>数据结构包括：线性结构和非线性结构。</p><p><strong>线性结构</strong></p><ul><li>1) 线性结构作为最常用的数据结构，其特点是 数据元素之间存在一对一的线性关系</li><li>2) 线性结构有两种不同的存储结构，即 顺序存储结构( 数组)和 链式存储结构( 链表)。顺序存储的线性表称为顺序<br>表，顺序表中的 存储元素是连续的</li><li>3) 链式存储的线性表称为链表，链表中的 存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地<br>址信息</li><li>4) 线性结构常见的有： 数组、队列、链表和栈，后面我们会详细讲解.</li></ul><p><strong>非线性结构</strong></p><p>非线性结构包括：二位数组，多为数组，广义表，树结构，图结构</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;字符串匹配问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个字符串，要判断另一个字符串中是否存在此字符串，要求用最快的速度来匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暴力匹配(简单，但是效率低)&lt;/li&gt;
&lt;li&gt;KMP算法《部分匹配表》&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java数据结构" scheme="https://hudu-gugui.github.io/tags/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="Java算法" scheme="https://hudu-gugui.github.io/tags/Java%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法(时间复杂度)</title>
    <link href="https://hudu-gugui.github.io/%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html"/>
    <id>https://hudu-gugui.github.io/算法-时间复杂度.html</id>
    <published>2019-09-04T10:44:17.000Z</published>
    <updated>2019-09-04T11:49:09.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Data Structure<br>数据存储的不同方式<br><em>例如:数组、链表</em></p><h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><p>同一个问题的不同的解决办法，算法往往是针对特定数据结构的</p><h1 id="如何测算算法的优劣"><a href="#如何测算算法的优劣" class="headerlink" title="如何测算算法的优劣"></a>如何测算算法的优劣</h1><ul><li>时间测算<ul><li>计算算法时间差</li><li>幅度不够循环来凑</li></ul></li><li>空间测算</li></ul><h1 id="Big-O"><a href="#Big-O" class="headerlink" title="Big O"></a>Big O</h1><p>时间针对于规模变化的规律</p><ul><li><p>时间-问题(数据)规模</p><ul><li>不考虑必须要做的操作<ul><li>循环、赋初值、程序初始化</li></ul></li><li>不考虑常数项<ul><li>2n – n</li></ul></li><li>不考虑低次项<ul><li>n^2+n – n^2</li></ul></li></ul></li><li><p>eg.</p><ul><li>访问数组某个位置的值    O(1)</li><li>访问链表某个位置的值    O(n)<ul><li>一般时间复杂度我们讲的都是”最差”的情况</li></ul></li><li>求数组平均值    O(n)</li></ul></li></ul><p>例如：一个数组，访问某个位置时候，需要一秒，当数组长度增加，访问某个位置时候还是只需要一秒，它的时间复杂度为O(1),他的时间复杂度是一个常数。</p><p>例如：访问一个链表的某个位置，访问时间需要n秒，当链表长度边长时，访问时间也边长，随着问题规模扩大，时间的变化线性变化，时间复杂度为O(n)</p><h1 id="常见的排序"><a href="#常见的排序" class="headerlink" title="常见的排序"></a>常见的排序</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>最简单，但是最没用的排序算法(O(n^2))，也有优化空间<br>算法的验证-随机数据生成器、对数器</p><p>先遍历，找到最小的数，和第一个交换，然后从第二个开始，往后遍历，找到最小的数，和第二个数交换，依次下去，直到排序结束</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;p&gt;Data Structure&lt;br&gt;数据存储的不同方式&lt;br&gt;&lt;em&gt;例如:数组、链表&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;什
      
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="String" scheme="https://hudu-gugui.github.io/tags/String/"/>
    
      <category term="StringBuffer" scheme="https://hudu-gugui.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="https://hudu-gugui.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer、StringBuilder区别</title>
    <link href="https://hudu-gugui.github.io/String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB.html"/>
    <id>https://hudu-gugui.github.io/String、StringBuffer、StringBuilder区别.html</id>
    <published>2019-09-01T09:40:23.000Z</published>
    <updated>2019-09-01T10:19:39.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1></blockquote><p>String属于对象，String的值是不可变的，这就导致每次对String操作对象都会生成新的String对象，下面为操作String的时的变化图：</p><p><img src="/images/String%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96%E5%9B%BE.png" alt="String内存变化图"></p><p>String的初始值为”hello”,然后再字符串上拼接了字符串”world”，这个过程需要重新在堆内存中开辟内存空间，最终得到”hello world”字符串也需要开辟内存空间，这样短短的两个字符串需要开辟三次内存空间，对内存有着极大的浪费，于是引入两个新的类，StringBuffer和StringBuilder</p><blockquote><h1 id="StringBuffer和StringBuilder类"><a href="#StringBuffer和StringBuilder类" class="headerlink" title="StringBuffer和StringBuilder类"></a>StringBuffer和StringBuilder类</h1></blockquote><p>当对字符串进行修改的时候，需要用到StringBuffer和StringBuilder类。<br>和String类不同的是，StringBuffer和StringBuilder类的对象能够被多次的修改，并且不产生对象。</p><p><strong>StringBuilder类</strong>在Java5中被提出，它和StringBuffer之间最大的不同在于StringBuilder的方法<strong>不是线程安全的(不能同步访问)</strong>，由于StringBuilder相较于StringBuffer有素的优势，所以多数情况下建议使用StringBuilder类，在线程安全情况下必须使用StringBuilder类。</p><blockquote><h1 id="三者继承结构"><a href="#三者继承结构" class="headerlink" title="三者继承结构"></a>三者继承结构</h1></blockquote><p><img src="/images/String,StringBuilder,StringBuffer%E7%BB%A7%E6%89%BF%E6%83%85%E5%86%B5.png" alt="三者继承情况"></p><blockquote><h1 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h1></blockquote><p><img src="/images/String,stringBuilder,StringBuffer%E5%8C%BA%E5%88%AB.png" alt="三者区别"></p><ul><li>(1)如果要操作少量的数据使用String。</li><li>(2)多线程字符串缓冲区下操作大量数据stringBuffer;</li><li>(3)单线程操作字符串缓冲区下大量数据StringBuilder;</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;String属于对象，String的值是不可变的，这就
      
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="String" scheme="https://hudu-gugui.github.io/tags/String/"/>
    
      <category term="StringBuffer" scheme="https://hudu-gugui.github.io/tags/StringBuffer/"/>
    
      <category term="StringBuilder" scheme="https://hudu-gugui.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>Java复习总结</title>
    <link href="https://hudu-gugui.github.io/Java%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93.html"/>
    <id>https://hudu-gugui.github.io/Java复习总结.html</id>
    <published>2019-08-27T06:01:33.000Z</published>
    <updated>2019-08-27T12:19:03.400Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="基础语法复习"><a href="#基础语法复习" class="headerlink" title="基础语法复习"></a>基础语法复习</h1></blockquote><h2 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h2><ul><li>面向对象</li><li>简单性：(相对于C和C++来说)Java不需要程序员操作内存</li><li>跨平台：一次编译，到处运行(JVM)</li><li>多线程：其他语言的对线程一般是系统级别的，Java的多线程是语言级别的</li><li>动态编译：(相对于C或者C++来说)，在一个项目中，如果要修改一个java文件的话，那么就修改这一个文件就可以了，其他的java文件不需要动。<a id="more"></a></li></ul><h2 id="垃圾回收机制-gc"><a href="#垃圾回收机制-gc" class="headerlink" title="垃圾回收机制(gc)"></a>垃圾回收机制(gc)</h2><p>Java不需要程序员释放内存，就是因为Java中有gc</p><ul><li>Java中垃圾回收处理的特点：<ul><li>1.由虚拟机通过垃圾回收线程自动完成。</li><li>2.只有当对象不再被使用，它的内存才会有可能被回收，如果虚拟机认为系统不需要额外的内存，即对象不再使用，内存也不会回收。</li><li>3.程序无法显示迫使垃圾回收机器立即回收，可以通过java.lang.System.gc()/java.lang.Runtime.gc()建议虚拟机回收对象。</li><li>4.垃圾回收器线程在释放无用对象占用内存之前会先行调用对象的finalize()方法。</li></ul></li></ul><h2 id="Java代码安全"><a href="#Java代码安全" class="headerlink" title="Java代码安全"></a>Java代码安全</h2><p><strong>Java程序执行流程</strong><br>编写.java文件-&gt;编译为.class文件-&gt;类加载-&gt;字节码验证-&gt;JIT运行</p><p>类加载：加载字节码文件,双亲委托机制,把我们写好并编译成的.class字节码文件从硬盘中加载到内存中</p><ul><li>字节码验证：<ul><li>验证代码是否和虚拟机版本匹配，版本向下兼容</li><li>代码不能破坏系统的完整性，也就是不能操作硬件</li><li>无堆栈上溢和下溢</li><li>参数类型是否正确</li><li>类型转换是否正确</li></ul></li></ul><ul><li>类加载器：<ul><li>1.启动类加载器：rt.jar</li><li>2.扩展类加载器：jre/lib/ext/</li><li>3.系统类加载器：自己的class</li><li>4.网络类加载器<br>双亲委托机制：向上委托，向下加载</li></ul></li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给类、接口、方法等变量起名字时使用的字符序列<br>由英文大小写字母、数字字符、$和_组成。不能使用关键字，并且不能以数字开头，区分大小写</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>boolean：true或false。在JVM中会转换为0或1<br>byte：8位整数<br>short：16位整数<br>char：16位unicode字符<br>int：32位整数<br>float：32位浮点数<br>double：64位浮点数<br>long：64位整数<br>1字节=8bit</p><p><strong>char的几种赋值方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> i1 = <span class="number">041</span>;<span class="comment">//八进制</span></span><br><span class="line">        System.out.println(i1);</span><br><span class="line">        <span class="keyword">char</span> i2 = <span class="number">33</span>;<span class="comment">//十进制</span></span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        <span class="keyword">char</span> i3 = <span class="number">0x21</span>;<span class="comment">//十六进制</span></span><br><span class="line">        System.out.println(i3);</span><br><span class="line">        <span class="keyword">char</span> i4 = <span class="string">'!'</span>;<span class="comment">//直接输入标点符号</span></span><br><span class="line">        System.out.println(i4);</span><br><span class="line">        System.out.println(<span class="string">"!的ASCII值的十进制表示数为："</span>+Integer.valueOf(i4));</span><br><span class="line">        <span class="keyword">char</span> i5 = <span class="string">'\u0021'</span>;<span class="comment">//16进制数据的unicode字符编码</span></span><br><span class="line">        System.out.println(i5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="images/CharTest.png" alt="char的几种赋值方式"></p><p><strong>二、八、十六及Unicode编码形式进行赋值</strong></p><p><em>在jdk1.7之后，就可以使用二进制数开始赋值</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二进制用<span class="number">0</span>b开头，比如：<span class="number">0b10</span>,由<span class="number">0</span>,<span class="number">1</span>组成。</span><br><span class="line">八进制用<span class="number">0</span>开头，比如：<span class="number">012</span>,由<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>...<span class="number">7</span>组成。</span><br><span class="line">十进制，常见整数，<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>...<span class="number">9</span>组成</span><br><span class="line">十六进制用<span class="number">0</span>x/<span class="number">0</span>X开头，比如：<span class="number">0x12</span>,由<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>...<span class="number">9</span>,a,b,c,d,e,f组成，不区分大小写</span><br><span class="line"></span><br><span class="line">程序中还有<span class="string">'\uxxxx'</span>，进行赋值的，这种以\u开头的是一个Unicode码的字符</span><br></pre></td></tr></table></figure><p><strong>转义字符</strong></p><p>对于有些特殊字符，比如单引号，如果不知道它的Unicode字符编码，直接从键盘输入，会编译出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">''</span><span class="string">';//编码出错</span></span><br><span class="line"><span class="string">为了解决这个问题，可采用转义字符来表示单引号和其他特殊字符；</span></span><br><span class="line"><span class="string">char c = '</span>\<span class="string">';</span></span><br><span class="line"><span class="string">char c = '</span>\\<span class="string">';</span></span><br><span class="line"><span class="string">转义字符以反斜杠开头，常用转义字符：</span></span><br><span class="line"><span class="string">\n*换行*</span></span><br><span class="line"><span class="string">\t垂直制表符，将光标移到下一个制表符的位置</span></span><br><span class="line"><span class="string">\\反斜杠字符</span></span><br><span class="line"><span class="string">\'单引号字符</span></span><br><span class="line"><span class="string">\"双引号字符</span></span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>(1)隐式类型转换：byte,short,char类型数据在进行数据运算的时候，会自动提升为int，其他类型运算时，表示范围小的会自动提升为大的，然后再运算，小类型可以直接赋值给大类型，类型自动转换为大的。</li><li>(2)显示类型转换：赋值过程中，大类型赋值给小类型会报错，出现精度损失，必须通过强制类型转换来实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">short</span> s = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//隐式类型转换</span></span><br><span class="line">        <span class="keyword">int</span> i1 = b + b;</span><br><span class="line">        <span class="keyword">int</span> i2 = s + s;</span><br><span class="line">        <span class="keyword">int</span> i3 = c + c;</span><br><span class="line">        System.out.println(i1+<span class="string">"\t"</span>+i2+<span class="string">"\t"</span>+i3);<span class="comment">//结果为2   4   194</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示类型转换，需要强制转换，浮点数转换为整数会舍去小数位</span></span><br><span class="line">        <span class="keyword">int</span> num1 = (<span class="keyword">int</span>)<span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = (<span class="keyword">int</span>)<span class="number">3.4f</span>;</span><br><span class="line">        <span class="keyword">float</span> f1 = <span class="number">3.20f</span>;</span><br><span class="line">        <span class="keyword">float</span> f2 = <span class="number">6.80f</span>;</span><br><span class="line">        <span class="keyword">float</span> f3 = f1 + f2;</span><br><span class="line">        <span class="keyword">double</span> d1 = <span class="number">3.20</span>;</span><br><span class="line">        <span class="keyword">double</span> d2 = <span class="number">6.80</span>;</span><br><span class="line">        <span class="keyword">double</span> d3 = d1 + d2;</span><br><span class="line">        <span class="comment">//结果是1000   3   10.0    10.0</span></span><br><span class="line">        System.out.println(num1+<span class="string">"\t"</span>+num2+<span class="string">"\t"</span>+f3+<span class="string">"\t"</span>+d3);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="keyword">false</span>?x:i);</span><br><span class="line">        System.out.println(<span class="keyword">false</span>?<span class="number">10</span>:x);<span class="comment">//因为此时的10不知道是什么类型所以输出x</span></span><br><span class="line">        System.out.println(<span class="keyword">false</span>?i:x);</span><br><span class="line">        <span class="comment">//结果分别是10   x   120</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java中变量：</p><ul><li>程序的基本功能是处理数据</li><li>程序用变量来接收并表示数据</li><li><font color="red">程序中必须先定义变量才能使用</font></li><li>定义变量是指设定变量的数据类型和变量的名字，Java语言要求变量遵循先定义，再初始化，然后再使用的规则。</li></ul><p>变量的使用有一个作用域的问题，作用域是指它的存在范围，只有在这个范围内，程序代码才能访问它。作用域决定了变量的生命周期，按照作用域不同，可以分为以下类型：</p><ul><li>成员变量：在类中声明，它的作用域是整个类；成员变量又叫做属性/实例变量</li><li>局部方法：在一个方法的内部或方法的一个代码块的内部声明。如果在一个方法内部声明，它的作用域是整个方法；如果在一个方法的某个代码块的内部声明，它的作用域是这个代码块。代码块是指位于一对大括号”{}”以内的代码。</li><li>方法参数：方法或者构造方法的参数，它的作用域是整个方法或者构造方法。</li><li>异常处理参数：和方法参数很相似，差别在于前者是传递参数给异常处理代码块，而后者是传递参数给方法或者构造方法。异常处理参数是指catch(Exception e)语句中的异常参数”e”，它的作用域是紧跟着catch(Exception e)语句后的代码块。</li></ul><p><font color="red">注意：</font><br>实例变量有默认值，使用之前可以不初始化；<br>基本类型中：<br>整型变量的默认值都是0<br>浮点型的默认值都是0.0<br>char默认值’\u0000’<br>boolean默认值是false<br>引用类型默认值都是null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//局部变量没有默认值，使用之前必须初始化</span></span><br><span class="line">    <span class="comment">//局部变量的生命周期，到这个局部变量所在的代码块结束为止</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">        <span class="keyword">int</span> c;<span class="comment">//使用之前必须初始化</span></span><br><span class="line">        <span class="keyword">if</span> (a==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">            b=a;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        b=20;//编出错，生命周期就在if循环代码块内</span></span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">//        System.out.println(x);//编译出错，局部变量使用之前必须初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> b;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();<span class="comment">//生命周期为，从一个对象被创建尅是，到这个对象被销毁</span></span><br><span class="line">        System.out.println(i);<span class="comment">//结果为0</span></span><br><span class="line">        System.out.println(c);<span class="comment">//结果为空即默认值是'\u0000'</span></span><br><span class="line">        System.out.println(b);<span class="comment">//结果为false</span></span><br><span class="line">        System.out.println(d);<span class="comment">//结果为0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符就是对常量和变量进行操作的符号</p><p><strong>分类：</strong>数学运算符、赋值运算符、比较运算符、三目运算符</p><p><strong>(1)数学运算符</strong></p><p><em>+、-、*、/、%、++、–</em></p><p><strong>(2)赋值运算符</strong><br><em>=、 *=、/= 、%= 、+= 、-=</em><br><strong>(3)比较操作符</strong><br><em>&gt;大于</em><br><em>&gt;= 大于等于</em><br>*&lt; 小于*<br>*&lt;= 小于等于*</p><p><font color="red">注意</font><br>instanceof：判断一个引用类型所引用的对象是否是有个类的实例。该操作符左边是一个引用类型，右边是一个类名或者接口名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceofTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//instanceof的用法</span></span><br><span class="line">    <span class="comment">//result = object instanceof class</span></span><br><span class="line">    <span class="comment">//result:布尔类型；object：必选项，任意对象表达式；class：必选项，任意已定的对象类</span></span><br><span class="line">    <span class="comment">//如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。</span></span><br><span class="line">    <span class="comment">// 如果 object 不是指定类的一个实例，或者 object 是 null，则返回 false。</span></span><br><span class="line">    <span class="comment">//编译状态中，class可以是object对象的父类，自身类，子类。在这三种情况下java编译不会报错</span></span><br><span class="line">    <span class="comment">//在运行状态中，class可以是object对象的父类，自身类，不能是子类。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        People people = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line">        System.out.println(people <span class="keyword">instanceof</span> Person);</span><br><span class="line">        System.out.println(people <span class="keyword">instanceof</span> Animal);</span><br><span class="line">        System.out.println(people <span class="keyword">instanceof</span> Object);</span><br><span class="line">        System.out.println(person <span class="keyword">instanceof</span> People);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;基础语法复习&quot;&gt;&lt;a href=&quot;#基础语法复习&quot; class=&quot;headerlink&quot; title=&quot;基础语法复习&quot;&gt;&lt;/a&gt;基础语法复习&lt;/h1&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;Java特点&quot;&gt;&lt;a href=&quot;#Java特点&quot; class=&quot;headerlink&quot; title=&quot;Java特点&quot;&gt;&lt;/a&gt;Java特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;面向对象&lt;/li&gt;
&lt;li&gt;简单性：(相对于C和C++来说)Java不需要程序员操作内存&lt;/li&gt;
&lt;li&gt;跨平台：一次编译，到处运行(JVM)&lt;/li&gt;
&lt;li&gt;多线程：其他语言的对线程一般是系统级别的，Java的多线程是语言级别的&lt;/li&gt;
&lt;li&gt;动态编译：(相对于C或者C++来说)，在一个项目中，如果要修改一个java文件的话，那么就修改这一个文件就可以了，其他的java文件不需要动。
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java复习" scheme="https://hudu-gugui.github.io/tags/Java%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性(Stream)</title>
    <link href="https://hudu-gugui.github.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7-Stream.html"/>
    <id>https://hudu-gugui.github.io/Java8新特性-Stream.html</id>
    <published>2019-08-26T06:42:21.000Z</published>
    <updated>2019-08-26T08:20:02.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h1></blockquote><p>Stream(流)是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。Java中的Stream不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。可以是集合，数组，I/O channel，产生器generator等</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作，比如filter，map，reduce，find，match，sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：<ul><li><strong>Pipelining</strong>:中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。</li><li><strong>内部迭代</strong>:以前对集合遍历都是通过lterator或者For-Each的方式，显示在集合外部进行迭代，这叫做外部迭代。Stream提供可内部迭代的方法，通过访问者模式(Visitor)显现。<a id="more"></a></li></ul></li></ul><blockquote><h1 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h1></blockquote><p>在Java8中，集合接口有两个方法来生成流：</p><ul><li>stream()-为集合创建串行流。</li><li>parallelStream()- 为集合创建并行流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string-&gt;string.isEmpty())</span><br><span class="line">.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h1></blockquote><p>Stream提供了新的方法’forEach’来迭代流中的每个数据。以下代码片段使用forEach输出了十个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1></blockquote><p>map方法用于映射每个元素到对应的结果，以下代码片段使用map输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map(i-&gt;i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><blockquote><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1></blockquote><p>filter方法用于通过设置的条件过滤出元素。以下代码片段使用filter方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">//获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string-&gt;string.isEmpty()).count();</span><br></pre></td></tr></table></figure><blockquote><h1 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h1></blockquote><p>limit方法用于获取指数量的流。以下代码片段使用limit方法打印出10条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><h1 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h1></blockquote><p>sorted方法用于对流进行排序，以下代码片段使用sorted方法对输出的10个数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><blockquote><h1 id="并行-parallel-程序"><a href="#并行-parallel-程序" class="headerlink" title="并行(parallel)程序"></a>并行(parallel)程序</h1></blockquote><p>parallelStream是并行处理程序的替代方法。以下实例使用parallelStream类输出空字符串数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><blockquote><h1 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h1></blockquote><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = string.stream().filter(string-&gt; !string.isEmpty()).collect(Collectors.toList);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"筛选列表："</span>+filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string-&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串："</span>+mergedString);</span><br></pre></td></tr></table></figure><blockquote><h1 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h1><p>另外，一些产生统计结果的收集器也非常有用。他们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">IntSummaryStatistics stats = number.stream().mapToInt((x)-&gt;x).summaryStatistics();</span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure><blockquote><h1 id="Stream完整实例"><a href="#Stream完整实例" class="headerlink" title="Stream完整实例"></a>Stream完整实例</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;什么是Stream&quot;&gt;&lt;a href=&quot;#什么是Stream&quot; class=&quot;headerlink&quot; title=&quot;什么是Stream&quot;&gt;&lt;/a&gt;什么是Stream&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;Stream(流)是一个来自数据源的元素队列并支持聚合操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;元素是特定类型的对象，形成一个队列。Java中的Stream不会存储元素，而是按需计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据源&lt;/strong&gt; 流的来源。可以是集合，数组，I/O channel，产生器generator等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚合操作&lt;/strong&gt; 类似SQL语句一样的操作，比如filter，map，reduce，find，match，sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pipelining&lt;/strong&gt;:中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部迭代&lt;/strong&gt;:以前对集合遍历都是通过lterator或者For-Each的方式，显示在集合外部进行迭代，这叫做外部迭代。Stream提供可内部迭代的方法，通过访问者模式(Visitor)显现。
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java8新特性" scheme="https://hudu-gugui.github.io/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="Stream" scheme="https://hudu-gugui.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特新(方法引用)</title>
    <link href="https://hudu-gugui.github.io/Java8%E6%96%B0%E7%89%B9%E6%96%B0-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html"/>
    <id>https://hudu-gugui.github.io/Java8新特新-方法引用.html</id>
    <published>2019-08-26T06:12:40.000Z</published>
    <updated>2019-08-26T06:49:15.417Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1></blockquote><ul><li>方法引用通过方法名来指向一个方法。</li><li>方法引用可以使语言的构造更加紧凑简洁，减少冗余代码。</li><li>方法引用使用一对冒号::<a id="more"></a>代码示例：</li></ul><p><strong>四种不同的方法引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">creat</span><span class="params">(<span class="keyword">final</span> Supplier&lt;Car&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collide</span><span class="params">(<span class="keyword">final</span> Car car)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Collided"</span>+car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">final</span> Car another)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Following the"</span>+another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repair</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Repaired"</span>+<span class="keyword">this</span>.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用：语法是Class:new，或者更一般的Class&lt;T&gt;::new实例如下：</span></span><br><span class="line"><span class="keyword">final</span> Car car = car.create(Car::<span class="keyword">new</span>);</span><br><span class="line"><span class="keyword">final</span> List&lt;Car&gt; cars = Arrays.asList(car);</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法引用：语法是Class::static_method,实例如下：</span></span><br><span class="line">cars.forEach(Car::collide);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特定类的任意对象的方法引用：它的语法是Class::method实例如下：</span></span><br><span class="line">cars.forEach(Car::repair);</span><br><span class="line"></span><br><span class="line"><span class="comment">//特性对此昂的方法引用：它的语法是instance:method实例如下：</span></span><br><span class="line"><span class="keyword">final</span> Car police = Car.create(Car::<span class="keyword">new</span>);</span><br><span class="line">Cars.forEach(police::follow);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;方法引用&quot;&gt;&lt;a href=&quot;#方法引用&quot; class=&quot;headerlink&quot; title=&quot;方法引用&quot;&gt;&lt;/a&gt;方法引用&lt;/h1&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方法引用通过方法名来指向一个方法。&lt;/li&gt;
&lt;li&gt;方法引用可以使语言的构造更加紧凑简洁，减少冗余代码。&lt;/li&gt;
&lt;li&gt;方法引用使用一对冒号::
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java8新特性" scheme="https://hudu-gugui.github.io/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="方法引用" scheme="https://hudu-gugui.github.io/tags/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="https://hudu-gugui.github.io/Java8%E6%96%B0%E7%89%B9%E6%80%A7.html"/>
    <id>https://hudu-gugui.github.io/Java8新特性.html</id>
    <published>2019-08-23T01:33:59.000Z</published>
    <updated>2019-08-23T08:17:28.634Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1></blockquote><p>Lambda表达式，也可以称为闭包，Lambda表达式允许把函数作为一个方法的参数(函数作为参数传递进方法中)。使用Lambda表达式可以使代码变得更加简洁紧凑。</p><blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters)-&gt;expression</span><br><span class="line">或</span><br><span class="line">(parameters)-&gt;&#123;statements;&#125;</span><br></pre></td></tr></table></figure><p>以下是Lambda表达式的重要特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。<a id="more"></a></li></ul><blockquote><h1 id="Lambda表达式实例"><a href="#Lambda表达式实例" class="headerlink" title="Lambda表达式实例"></a>Lambda表达式实例</h1></blockquote><p>Lambda表达式的简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.不需要参数，返回值为5</span></span><br><span class="line">()-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接收一个参数(数字类型)，返回其2倍的值</span></span><br><span class="line">x-&gt;<span class="number">2</span>*x</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.接受两个参数(数字),并返回他们的差值</span></span><br><span class="line">(x,y)-&gt;x-y</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.接收2个int类型整数，返回他们的和</span></span><br><span class="line">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)-&gt;x+y</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.接受一个String对象，并在控制台打印，不返回任何值(看起来像是返回void)</span></span><br><span class="line">(String s)-&gt;System.out.print(s)</span><br></pre></td></tr></table></figure><p><strong>Lambda表达式实例演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Java8Test1 tester = <span class="keyword">new</span> Java8Test1();</span><br><span class="line">        <span class="comment">//普通的创建一个对象的过程</span></span><br><span class="line">        MathOperation mo = <span class="keyword">new</span> MathOperation() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a*b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//上面的用Lambda表达式简化，因为有两个参数，括号无法省略</span></span><br><span class="line">        <span class="comment">//因为返回只有一行，所有可以省略return；</span></span><br><span class="line">        MathOperation mo1 = (a, b) -&gt; a*b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"2x3="</span>+tester.operate(<span class="number">2</span>,<span class="number">3</span>,mo1));</span><br><span class="line"></span><br><span class="line">        GreetingService gs = <span class="keyword">new</span> GreetingService() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello"</span>+message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//用Lambda表达式简化</span></span><br><span class="line">        GreetingService gs1 = message -&gt; System.out.println(<span class="string">"Hello "</span>+message);</span><br><span class="line">        <span class="comment">//最简洁的表达式</span></span><br><span class="line">        GreetingService gs2 = System.out::println;</span><br><span class="line"></span><br><span class="line">        gs1.sayMessage(<span class="string">"Runoob"</span>);</span><br><span class="line">        gs2.sayMessage(<span class="string">"Google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,MathOperation mathOperation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="images/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="Lambda表达式"></p><p><strong>使用Lambda表达式注意一下两点</strong></p><ul><li>Lambda表达式主要用来定义行内执行的方法类型接口，例如，一个简单的方法接口。在上面的例子中，使用Lambda表达式来定义MathOperation接口的方法，然后定义了sayMessage的执行。</li><li>Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。</li></ul><blockquote><h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1></blockquote><p>Lambda表达式只能引用标记了final的外层局部变量，就是说不能再Lambda外部修改定义在域外的局部变量，否则会编译错误。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Test1_1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String saluation = <span class="string">"Hello "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当Lambda表达式引用saluation1时，成员变量默认是final修饰，不能修改。</span></span><br><span class="line">        String saluation = <span class="string">"Hello "</span>;</span><br><span class="line">        GreetingService gs = message -&gt; System.out.println(saluation+message);<span class="comment">//并且定义的传入的参数名不能和局部变量的变量名一样</span></span><br><span class="line">        gs.sayMessage(<span class="string">"World"</span>);</span><br><span class="line"><span class="comment">//        saluation1="123";//无法修改</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="images/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F.png" alt="Lambda表达式变量作用域"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;Lambda表达式，也可以称为闭包，Lambda表达式允许把函数作为一个方法的参数(函数作为参数传递进方法中)。使用Lambda表达式可以使代码变得更加简洁紧凑。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(parameters)-&amp;gt;expression&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(parameters)-&amp;gt;&amp;#123;statements;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;以下是Lambda表达式的重要特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。&lt;/li&gt;
&lt;li&gt;可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。&lt;/li&gt;
&lt;li&gt;可选的大括号：如果主体包含了一个语句，就不需要使用大括号。&lt;/li&gt;
&lt;li&gt;可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="Java8新特性" scheme="https://hudu-gugui.github.io/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
      <category term="Lambda表达式" scheme="https://hudu-gugui.github.io/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="方法引用" scheme="https://hudu-gugui.github.io/tags/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    
      <category term="函数式接口" scheme="https://hudu-gugui.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="默认方法" scheme="https://hudu-gugui.github.io/tags/%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    
      <category term="Stream" scheme="https://hudu-gugui.github.io/tags/Stream/"/>
    
      <category term="Optional类" scheme="https://hudu-gugui.github.io/tags/Optional%E7%B1%BB/"/>
    
      <category term="Nashorn及JavaScript引擎" scheme="https://hudu-gugui.github.io/tags/Nashorn%E5%8F%8AJavaScript%E5%BC%95%E6%93%8E/"/>
    
      <category term="新的日期时间API" scheme="https://hudu-gugui.github.io/tags/%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API/"/>
    
      <category term="Base64" scheme="https://hudu-gugui.github.io/tags/Base64/"/>
    
  </entry>
  
  <entry>
    <title>IO流和文件系统</title>
    <link href="https://hudu-gugui.github.io/IO%E6%B5%81%E5%92%8C%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html"/>
    <id>https://hudu-gugui.github.io/IO流和文件系统.html</id>
    <published>2019-08-22T03:30:20.000Z</published>
    <updated>2019-08-22T03:30:20.966Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="https://hudu-gugui.github.io/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html"/>
    <id>https://hudu-gugui.github.io/网络编程.html</id>
    <published>2019-08-21T11:58:20.000Z</published>
    <updated>2019-08-22T03:29:16.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1></blockquote><p><strong>1.IP地址</strong><br>IP是Internet Protocol【网络协议】的缩写，IP地址指的是在一个网络【万维网】环境中用于确定某一台计算机主机的标识；IP由4个字节组成，每个字节是一段，每段之间用“.”分隔；一个计算机主机可以有多个IP地址；但是一个IP地址只能确定唯一的一台计算机主机。<br><strong>2.端口</strong><br>为计算机中运行的网络应用程序分配的应用程序标识；取值范围值0到65535，但是0到1023【前1024个】由操作系统软件保留；</p><a id="more"></a><p><strong>3.URL</strong><br>称为统一资源定位符：网址<br>例如<font color="red"><a href="https://www.baidu.com:80/index.html" target="_blank" rel="noopener">https://www.baidu.com:80/index.html</a></font></p><p>https://网络传输协议<br><a href="http://www.baidu.com是主机名" target="_blank" rel="noopener">www.baidu.com是主机名</a><br>80位服务器的端口<br>/index.html为服务器的根目录和资源</p><p><strong>4.URI统一资源标识符</strong><br>就是如上所述的x.html<br>DNS：Domain Name System。域名系统，域名解析器</p><p><strong>5.Java中使用InetAdderss类描述IP地址</strong><br>InetAdderss    IPv4<br>InetAdderss Ipv6</p><p>hosts文件：文件中可以配置主机名到IP地中的映射关系：<br>windows：C:\Windows\System32\drivers\etc\hosts<br>Linux/Unix: /etc/hosts</p><p>格式：<br>IP地址 &nbsp; 主机名<br>127.0.0.1 &nbsp; localhost</p><blockquote><h1 id="2-TCP编程【TCP协议】"><a href="#2-TCP编程【TCP协议】" class="headerlink" title="2.TCP编程【TCP协议】"></a>2.TCP编程【TCP协议】</h1></blockquote><p><strong>1.Socket</strong><br>主要用于TCP通信的客户端<br>Socket(String host, int port);    创建Socket对象，用于连接服务器进行通信，<br>在使用此构造器创建Socket对象的时候，客户端的Socket就会根据参数传递的IP地址和端口<br>去连接服务器端的ServerSocket；</p><p><strong>2.ServerSocket</strong><br>主要用于TCP通信服务端；<br>ServerSocket(int port);  // 此构造器用于创建一个服务器端的ServerSocket对象，<br>在创建时需要监听一个端口，当客户端的Socket对象连接此端口时，就能被该ServerSocket对象识别并且接收；</p><p>Socket accept();    // 在服务器端用于监听并获取客户端的Socket对象，目的是建立传输数据的通道；<br>实际上服务器端的ServerSocket并不会直接和客户端的Socket进行数据传输【通信】，<br>通信通道的建立是由服务器端的ServerSocket所获取到的客户端的Socket对象以及客户端本身的Socket对象建立的；<br>此方法是阻塞式方法；</p><p><strong>3.TCP协议的特点</strong><br>    1.可靠的网络协议，安全，数据传输之前要“三次握手”；<br>    2.效率相对低下，但是安全；<br>    3.在传输数据时，客户端和服务器端都必须“在线”；</p><p>练习：1.客户端循环发，服务器循环接收；<br>      2.基于TCP的聊天系统；<br>      3.多线程聊天；</p><blockquote><h1 id="3-UDP编程【UDP协议】，发送端、接收端"><a href="#3-UDP编程【UDP协议】，发送端、接收端" class="headerlink" title="3.UDP编程【UDP协议】，发送端、接收端"></a>3.UDP编程【UDP协议】，发送端、接收端</h1></blockquote><p>1.面向无连接；<br>2.不安全，数据容易丢失；<br>3.效率相对于TCP高一些；<br>4.UDP发送的数据会被封装成数据报包，每个数据报的大小不会超过64KB;</p><p>5.在Java中基于UDP的编程由DatagramSocket提供数据传输的两端；由DatagramPacket封装数据；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket：</span><br><span class="line">DatagramSocket();  <span class="comment">//创建发送端的Socket对象</span></span><br><span class="line">DatagramSocket(<span class="keyword">int</span> port);  <span class="comment">//创建接收端的Socket对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> <span class="comment">//从此套接字接收数据报包。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(DatagramPacket p)</span> <span class="comment">//从此套接字发送数据报包。</span></span></span><br><span class="line"><span class="function">DatagramPacket：</span></span><br><span class="line"><span class="function"><span class="comment">//对要发送的数据进行封装或者用该类的对象来接收</span></span></span><br><span class="line"><span class="function"><span class="comment">//DatagramSocket收到的数据；</span></span></span><br><span class="line"><span class="function"><span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//构造 DatagramPacket，用来接收长度为 length 的数据包。</span></span></span><br><span class="line"><span class="function"><span class="title">DatagramPacket</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。</span></span></span><br></pre></td></tr></table></figure><blockquote><h1 id="TCP代码实例"><a href="#TCP代码实例" class="headerlink" title="TCP代码实例"></a>TCP代码实例</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket cs = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">1666</span>);</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        OutputStream os = cs.getOutputStream();</span><br><span class="line">        PrintWriter pw = <span class="keyword">new</span> PrintWriter(os, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入要发送的消息："</span>);</span><br><span class="line">            String msg = reader.readLine();</span><br><span class="line">            pw.println(msg);</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader</span><br><span class="line">                    (<span class="keyword">new</span> InputStreamReader(cs.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">"服务器消息："</span>+br.readLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端代码</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">1666</span>);</span><br><span class="line">        String sIP = ss.getInetAddress().getHostAddress();</span><br><span class="line">        System.out.println(<span class="string">"服务"</span>+sIP+<span class="string">"启动了！"</span>);</span><br><span class="line">        Socket cs = ss.accept();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            String cIP = cs.getInetAddress().getHostAddress();</span><br><span class="line">            System.out.println(<span class="string">"客户端"</span>+cIP+<span class="string">"进来了"</span>);</span><br><span class="line">            InputStream is = cs.getInputStream();</span><br><span class="line">            BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">            String msg = br.readLine();</span><br><span class="line">            System.out.println(<span class="string">"客户端消息:"</span>+msg);</span><br><span class="line">            OutputStream os = cs.getOutputStream();</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> PrintWriter(os, <span class="keyword">true</span>);</span><br><span class="line">            pw.println(<span class="string">"接收到消息"</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：<br><img src="/images/TCP_2.png" alt="客户端"><br><img src="/images/TCP_1.png" alt="服务器端"></p><blockquote><h1 id="UDP实例代码"><a href="#UDP实例代码" class="headerlink" title="UDP实例代码"></a>UDP实例代码</h1></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SendThread().start();</span><br><span class="line">        <span class="keyword">new</span> ReceiveThread().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SendThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">            InetAddress ia = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">            <span class="keyword">int</span> port=<span class="number">45678</span>;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//                System.out.println("请输入消息");</span></span><br><span class="line">                line=reader.readLine();</span><br><span class="line">                <span class="keyword">if</span> (line==<span class="keyword">null</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"886"</span>.equals(line))<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = line.getBytes();</span><br><span class="line">                <span class="keyword">int</span> length = bytes.length;</span><br><span class="line"></span><br><span class="line">                DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length, ia, port);</span><br><span class="line">                ds.send(dp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">45678</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">            <span class="keyword">int</span> length = bytes.length;</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes, length);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                ds.receive(dp);</span><br><span class="line">                String sIP = dp.getAddress().getHostAddress();</span><br><span class="line">                <span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">                <span class="keyword">int</span> length1 = data.length;</span><br><span class="line">                String data1 = <span class="keyword">new</span> String(data,<span class="number">0</span>,length1);</span><br><span class="line">                System.out.println(sIP+<span class="string">"\t说;"</span>+data1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行效果图：<br><img src="images/" alt="UDP"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.IP地址&lt;/strong&gt;&lt;br&gt;IP是Internet Protocol【网络协议】的缩写，IP地址指的是在一个网络【万维网】环境中用于确定某一台计算机主机的标识；IP由4个字节组成，每个字节是一段，每段之间用“.”分隔；一个计算机主机可以有多个IP地址；但是一个IP地址只能确定唯一的一台计算机主机。&lt;br&gt;&lt;strong&gt;2.端口&lt;/strong&gt;&lt;br&gt;为计算机中运行的网络应用程序分配的应用程序标识；取值范围值0到65535，但是0到1023【前1024个】由操作系统软件保留；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="网络编程" scheme="https://hudu-gugui.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="https://hudu-gugui.github.io/tags/TCP/"/>
    
      <category term="UDP" scheme="https://hudu-gugui.github.io/tags/UDP/"/>
    
      <category term="IP" scheme="https://hudu-gugui.github.io/tags/IP/"/>
    
      <category term="port" scheme="https://hudu-gugui.github.io/tags/port/"/>
    
  </entry>
  
  <entry>
    <title>线程(Thread)</title>
    <link href="https://hudu-gugui.github.io/%E7%BA%BF%E7%A8%8B-Thread.html"/>
    <id>https://hudu-gugui.github.io/线程-Thread.html</id>
    <published>2019-08-12T10:48:30.000Z</published>
    <updated>2019-08-12T12:26:38.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1></blockquote><p><strong>1.进程：</strong><br>进程就是某一个应用程序在计算机中运行时计算机为该应用程序所分配的资源；在多任务计算机中一个计算机可以同时执行多个程序，也就是有多个进程；进程不具备计算能力的；<br><strong>2.线程：</strong><br>线程是进程中使用【利用】计算机为进程所分配的计算机资源进行数据计算的基本单位；一个进程中至少要包含一个线程，否则该进程无意义；线程具有随机【执行】性，线程的运行时接受CPU的调度的，当CPU调度到哪个线程就执行哪个线程，并且一个CPU在某个时间片之内【同一时刻】只能执行一个线程，形象的理解为线程在抢夺CPU资源，如果抢到了就执行；<br><strong>3.多线程</strong><br>当一个进程中多个线程“同时”执行，此现象称之为多线程；</p><a id="more"></a><blockquote><h1 id="自定义线程和创建执行线程"><a href="#自定义线程和创建执行线程" class="headerlink" title="自定义线程和创建执行线程"></a>自定义线程和创建执行线程</h1></blockquote><h2 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类:"></a>1.继承Thread类:</h2><p>(1)Thread类中默认的run方法的方法体为“空”，不会执行任何代码；<br>(2)继承该类之后，需要重写该类中的run()方法，将自定义的线程需要执行的代码写在run()方法中，在该线程被启动之后，线程就会去执行run()方法中的代码；<br>(3)线程的启动是调用Thread类中的start()方法，而不能直接调用run()方法，如果调用run方法就是最简单的方法调用而不是线程的启动；<br>(4)Java程序在执行的时候，JVM进程会启动一个线程来执行该程序的主方法，此线程称之为main线程【主线程，线程的名字叫“main”】；只有主线程在执行main方法的时候才能执行到main方法中定义的创建和启动其他线程的代码，如果启动了多个线程，则这些线程的默认的名字是按照启动顺序从“Thread-0”到“Thread-N”;<br>(5)start()方法和run()方法的区别：<br>&emsp;1.run方法中用于定义线程执行的代码；如果直接调用run方法，则相当于普通方法调用；<br>&emsp;2.start方法用于启动线程，让该线程能够抢占CPU资源而执行；</p><h2 id="2-实现Runnable接口："><a href="#2-实现Runnable接口：" class="headerlink" title="2.实现Runnable接口："></a>2.实现Runnable接口：</h2><p>1.该接口中只有一个方法——run方法；<br>2.自定义类实现了该接口并且重写run方法，在run方法中定义线程要执行的代码；<br>3.实现了该接口的类并不是线程类，只是表示该类的对象可以作为线程对象的执行目标来执行；</p><h2 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h2><p>该接口中有一个方法call方法，该方法是具有返回值的，如果线程在执行的过程中调用了一个具有返回值的方法，则可以使用该接口创建线程；</p><blockquote><h1 id="线程的状态-生命周期"><a href="#线程的状态-生命周期" class="headerlink" title="线程的状态(生命周期)"></a>线程的状态(生命周期)</h1></blockquote><p>1.并发：多个线程同时执行称之为并发；<br>并行：多个进程同时执行称之为并行；</p><p>2.线程中的优先级：<br>Java中的每个线程都有优先级，但是优先级高的线程被CPU调度的概率高于优先级低的线程；设置线程的优先级并不能让CPU立即去执行线程，而是让CPU有更多机会来调度该线程；线程的优先级被分为10个等级，用int类型的1到10表示，10表示优先级最高，1表示优先级最低，5是Java中所有线程的默认优先级；</p><p>2.Thread类中方法：</p><ol><li>static Thread currentThread();  // 获取此代码所在的方法正在被执行的线程对象；</li><li>static void sleep(long ms); // 让执行此代码所在的方法的线程暂时停止执行【CPU不再调度该线程】，等到参数所表示的时间结束之后可以继续执行；</li></ol><p>3.Object类中的方法：</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.进程：&lt;/strong&gt;&lt;br&gt;进程就是某一个应用程序在计算机中运行时计算机为该应用程序所分配的资源；在多任务计算机中一个计算机可以同时执行多个程序，也就是有多个进程；进程不具备计算能力的；&lt;br&gt;&lt;strong&gt;2.线程：&lt;/strong&gt;&lt;br&gt;线程是进程中使用【利用】计算机为进程所分配的计算机资源进行数据计算的基本单位；一个进程中至少要包含一个线程，否则该进程无意义；线程具有随机【执行】性，线程的运行时接受CPU的调度的，当CPU调度到哪个线程就执行哪个线程，并且一个CPU在某个时间片之内【同一时刻】只能执行一个线程，形象的理解为线程在抢夺CPU资源，如果抢到了就执行；&lt;br&gt;&lt;strong&gt;3.多线程&lt;/strong&gt;&lt;br&gt;当一个进程中多个线程“同时”执行，此现象称之为多线程；&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="线程" scheme="https://hudu-gugui.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="thread" scheme="https://hudu-gugui.github.io/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://hudu-gugui.github.io/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html"/>
    <id>https://hudu-gugui.github.io/面向对象.html</id>
    <published>2019-08-11T02:46:28.000Z</published>
    <updated>2019-08-11T03:12:25.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1></blockquote><p>(1)包：最好是域名倒过来，要求所有的额字母小写。<br>(2)类或者接口：如果是一个单词首字母大写，如果是多个单词，每个单词首字母大写(驼峰命名)<br>(3)方法或变量：如果是一个单词，首字母小写，如果是多个单词，从第二个单词首字母大写<br>(4)常量：如果是一个单词，所有字母大写，如果是多个单词，所有的单词大写，用下划线区分每个单词<br>常量的概念：在执行过程中其值不能改变，字符串常量（双引号括起来的内容），整数常量，小数常量，字符常量，布尔常量，空常量</p><a id="more"></a><blockquote><h1 id="理解对象的概念"><a href="#理解对象的概念" class="headerlink" title="理解对象的概念"></a>理解对象的概念</h1></blockquote><p>面向对象的开发方法把软件系统看成各种对象的集合，对象就是最小的子系统，一组相关的对象能够组合成更复杂的子系统。面向对象的开发方法将软件系统看成各种对象的集合，接近人的自然思维方式。<br>对象是对问题领域中事件的抽象。对象具有以下特性：<br>(1) 万物皆为对象。问题领域中的实体和概念都可以抽象为对象。例如学生，成绩单、教师、课和教室。<br>(2) 每个对象都是惟一的。正如世界上不存在一模一样的叶子。<br>(3) 对象具有属性和行为。<br>例如小张，性别女，年龄22，身高1.6m, 体重40kg, 能够学习，唱歌。小张的属性包括姓名、性别、年龄、身高和体重，行为包括学习、唱歌。<br>例如一部手机，牌子是诺基亚、价格是2000元，银白色，能够拍照、打电话和收发短信等。这部手机的属性包括品牌类型type、价格price和颜色color，行为包括拍照takePhoto()，打电话call()，收发短信receiveMessage()和发短信sendMessage().<br>(4) 对象具有状态。状态是指某个瞬间对象的各个属性的取值。对象的某些行为会改变对象自身的状态，即属性的取值。例如小张本来体重为40kg，经为减肥后，体重减到45kg.<br>肥胖状态: 40kg—减肥行为—肥胖状态: 35kg<br>(5) 每个对象都是某个类的实例。小张和小王都属于学生类、中国和美国都属于国家类、中文和英文都属于语言类。类是具有相同属性和行为的对象的集合。</p><p>同一个类的所有实例都有相同属性，但属性取值不一事实上相同，但是它们的状态不一定相同。例如小张和小王都属于学生类，都有姓名、性别、年龄、身高和体重这些属性，但是他们的属性取值不同。</p><p>同一个类的所有实例都有相同行为，意味着它们具有一些相同的功能。</p><blockquote><h1 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h1></blockquote><p>类是一组具有相同属性和行为对象的模板。面向对象编程的主要任务就是定义对象模型中的各个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**attributes of a teacher*/</span></span><br><span class="line">          <span class="keyword">private</span> String name;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/** Creates a new instance of Teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.salary = salary;</span><br><span class="line">              <span class="keyword">this</span>.age = age;</span><br><span class="line">              <span class="keyword">this</span>.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/**operations on properties */</span></span><br><span class="line">          <span class="comment">/** get the name of this teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">          <span class="comment">/**get the salary of this teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> salary; &#125;</span><br><span class="line">          <span class="comment">/**get the age of teacher teacher */</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">          ……</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>代码解析：</p><p>(1)package sample;<br>包声明语句，将Java类放到特定的包中，便于类的组织、权限访问和区分名字相同的类。<br>(2)public class Teacher{···}<br>类的声明语句，类名为Teacherr,public修饰符意味着这个类可以被公开访问：<br>类的声明格式：<br>class 类名 {<br>             类内容<br>         }</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h1 id=&quot;命名规则&quot;&gt;&lt;a href=&quot;#命名规则&quot; class=&quot;headerlink&quot; title=&quot;命名规则&quot;&gt;&lt;/a&gt;命名规则&lt;/h1&gt;&lt;/blockquote&gt;
&lt;p&gt;(1)包：最好是域名倒过来，要求所有的额字母小写。&lt;br&gt;(2)类或者接口：如果是一个单词首字母大写，如果是多个单词，每个单词首字母大写(驼峰命名)&lt;br&gt;(3)方法或变量：如果是一个单词，首字母小写，如果是多个单词，从第二个单词首字母大写&lt;br&gt;(4)常量：如果是一个单词，所有字母大写，如果是多个单词，所有的单词大写，用下划线区分每个单词&lt;br&gt;常量的概念：在执行过程中其值不能改变，字符串常量（双引号括起来的内容），整数常量，小数常量，字符常量，布尔常量，空常量&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://hudu-gugui.github.io/categories/Java/"/>
    
    
      <category term="面向对象" scheme="https://hudu-gugui.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="命名" scheme="https://hudu-gugui.github.io/tags/%E5%91%BD%E5%90%8D/"/>
    
  </entry>
  
</feed>
